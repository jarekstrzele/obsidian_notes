
>[!important] wyrażenia
> - jeden z podstawowych składników, z których budujemy funkcje,
> - mają wartości (np. `5*(fahr-32)/9` ), zaś instrukcje nie (`np. for(begin != end)) ...`
> - ==Rust jest językiem wyrażeń *expression language*==
> - W języku  C `if` i `switch` są instrukcjami. Nie produkują żadnej wartości, nie mogą być użyte jako część innego wyrażenia. W języku Rust `if` czy `match` mogą mieć wartość.
> - W C za sterowanie odpowiadają praktycznie tylko instrukcje. W Ruście wyłącznie wyrażenia.
> - przykładowe wyrażenia:
> > - `[1,2,3]` literał tablicowy
> > - `{f();g()}` blok
> > - wyrażenia sterujące 
> >>  - `if` , `else`, `while`, `break` ...
> > - referencje, dereferencje 
> > - domknięcia `|x,y| x + y`
> > - ...



# Priorytety i łączność operatorów

**mogę być łączone w łańcuchy**
- operatory lewostronne ,
- *lewostronność*: `a-b-c <=> (a-b)-c`
- `* / % + - << >> & ^ | && || as`

**operatory niemogące łączyć się w łańcuchy*
- porównania,
- przypisania
- operatory zakresu:
	- `..`
	- `..=`


# Bloki kodu i średniki
>[!definition] blok
>- to wyrażenie,
>- generuje wartość
>- syntaktyk `{ ... }`
>- pusta krotka `()` jest wartością całego bloku, gdy w bloku kodu we wszystkich miejsca występuje `;`
>- jeżeli ostatnie wyrażenie w bloku nie ma średnika, jest wartością zwracaną przez blok

```rust
let msg = {

// Deklaracja let: średnik obowiązkowy
	let dandelion_control = puffball.open();
	
// Wyrażenie + średnik: funkcja wywołana, zwrócona wartość pominięta
	dandelion_control.release_all_seeds(launch_codes);
	
// Wyrażenie bez średnika: funkcja wywołana,
// wartość zwrócona przez funkcję to wartość całego bloku, trafia do ‘msg’
	
	dandelion_control.get_status() 
};
```


# Deklaracja

- `let nazwa: typ = wyrażenie ;` - stworzenie zmiennej lokalnej 
- deklaracja `let` nie musi inicjalizować zmiennej `let name;`
- użycia zmiennej przed jej zainicjalizowaniem traktowana jest jako błąd

**przesłanianie**/*shadowing*
```rust
for line in file.lines() {
	let line = line?; 
	...
}
```
- Deklaracja `let` tworzy nową, drugą zmienną innego typu. 
- Pierwsza zmienna `line` jest typu `Result<String, io::Error>`, natomiast 
- druga zmienna `line` jest typu `String`. 
- Jej definicja **przesłania** pierwszą zmienną `line` aż do końca bloku.


# `if`, `match`

```rust
if warunek1 { 
	blok1
} else if warunek2 { 
	blok2
} else {
	blok_n
}
```

- Rust nie dokonuje niejawnej konwersji do typu logicznego wartości numerycznych czy wskaźników.
- Warunki nie muszą 













