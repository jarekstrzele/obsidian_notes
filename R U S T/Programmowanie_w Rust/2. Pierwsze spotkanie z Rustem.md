`cargo` menedżer kompilacji i budowani projektów
`rustc` właściwy kompilator Rusta
`rustdoc` narzędzie do generowania dokumentacji'


### `cargo projectName`
`cargo.toml` zawiera informacje o pakiecie


### `cargo run` 
zbuduje plik wykonywalny i uruchomi go (pliki trafiają do katalogu `target`)

`target/debug/hello.exe`

#  Funkcje w Rust
algorytm Euklidesa(największy wspólny dzielnik):
```rust
fn gcd(mut n: u64, mut m: u64) -> u64 {
	assert!(n != 0 && m != 0) ;
	while m != 0 {
		if m < n {
			let t = m ;
			m = n ;
			n = t ;
		}
		m = m % n ;
	}
}
```

- Domyślnie **zmienna** raz zainicjalizowana **nie może być później modyfikowana**.
- Gdy chcemy by do zmiennej można było przypisywać po inicjalizacji **inne wartości** (zmienne mutowalne), należy przy jej **deklaracji** użyć słowa kluczowego `mut` (ang. mutable). 
	- Dotyczy to również deklaracji parametrów funkcji. 
`let` deklaracja zmiennej lokalnej

>[!info]
>Rust jest w stanie wywnioskować typy zmiennych jedynie wewnątrz funkcji. 
Typy parametrów funkcji i typ wartości przez funkcję zwracanej muszą być zadeklarowane jawnie.


W języku Rust występuje słowo kluczowe `return`, obowiązuje następująca zasada: 
>jeśli ciało funkcji kończy się wyrażeniem, po którym nie występuje średnik, to wartość wyrażenia jest wartością zwracaną przez funkcję.

---
# Pisanie i uruchamianie testów
na końcu pliku, gdzie zdefiniowano `gcd()`
```rust
#[test]
fn test_gcd() {
	assert_eq!(gcd(14, 15), 1);
	assert_eq!(gcd(2 * 3 * 5 * 11 * 17,
	3 * 7 * 11 * 13 * 19),
	3 * 11);
}
```
`#[test]` - [[atrybut]], który definiuje, że funkcja poniżej będzie funkcją testującą, więc będzie pomijana w czasie kompilacji, a będzie kompilowana gdy napiszemy `cargo test`



# Obsługa argumentów wiersza poleceń
#rust/iterator
**iteratory** są bardzo często używane, i są bardzo dobrze optymalizowana przez kompilator
Biblioteka standardowa oferuje iteratory, za pomocą których przegladamy elementy wektora, pobieramy kolejne wiersze pliku, wiadomości z kanału komunikacyjnego ...

```rust
use std::str::FromStr ;
use std::env;
```
do bieżącego zasięgu importuje zestaw metod(*trait*) `FromStr` z biblioteki standardowej 
	- każdy typ implementujący zestaw `FromStr` dysponuje metodą `from_str` (analizuje łańcuch znaków i przekształca go na wartość danego typu)
	- typ `u64` implementuje zestaw `FromStr` dlatego możemy wywołać metodę `u64::from_str`, aby zmienić argumenty wiersza poleceń na liczby
 
`std::env` dostarcza zestaw funkcji i typów do interakcji ze środowiskiem wykonawczym (np. funkcję `args` - zapewnia dostęp do argumentów wiersza poleceń)

`let mut numbers: Vec<u64> = Vec::new();` lokalna zmienna mutowalna z wartością pustego wektora

`std::env::args()` zwraca **iterator** (mamy dostęp do kolejnych argumentów)
`.skip(1)` pomija pierwszą wartość iteratora, którą jest nazwa uruchamianego programu (ta metod)












