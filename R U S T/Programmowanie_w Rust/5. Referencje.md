[[_ Programowanie w języku Rust]]

`Box<T>` (umieszczają wartość na stercie), `String` i `Vec` (korzystają z bufora na stercie) :
- to zmienne wskaźnikowe posiadające prawo własności, czyli są właścicielami wartości,
- zmienna przestaje istnieć --> wartość przez nią wskazywania przestaje istnieć.


==Istnieją w Ruście wskaźniki (zwane referencjami), które nie są właścicielami wartości==.:
- Cykl ich życia nie determinuje cyklu życia wartości, na które wskazują.
- referencja z założenia nie może istnieć dłużej niż wartość, na którą wskazuje (zwykle istnieje krócej)
- w Ruście tworzenie referencji często określane jest jako "pożyczanie" wartości (korzystamy z niej, ale nigdy nie jest nasza)
- referencje to po prostu adresy do obszarów pamięci, ale Rust wprowadza swoje zasady posługiwania nimi --> daje bezpieczeństwo posługiwania się nimi



## Referencje do WARTOŚCI

**Referencja pozwala na dostęp do wartości, który nie wiąże się jednak z przeniesieniem własności.**:
- referencja współdzielona (*shared reference*) - `&e:
	- umożliwia tylko odczytywanie wskazywanej wartości
	- w tym samym czasie można mieć dowolną liczbę tych referencji wskazujących na ten sam obiekt
	- `&e` tworzy referencję współdzieloną dla wartości `e`
	- jeśli `e` jest typu `T`. wyrażenie `&e` jest typu `&T`

 >[!definition] referencja mutowalna (*mutable reference*) - `&mut e`
 >- wartość przez nią wskazywana może być:
 >>- odczytywania
 >>- modyfikowana
 >- w jednym czasie może istnieć tylko jedna taka referencja dla danej wartości
> - `&mut e` tworzy referencję mutowalną dla wartośći `e`
> - jeśli `e` jest typu `T`, referencja jest typu `&mut T`

>[!important] własność i pożyczanie wartości
>- dopóki istnieje przynajmniej jedna **referencja współdzielona** wskazująca na wartość i możliwiająca jej odczyt, nie może dojść do modyfikacji tej wartości, nawet przez właściciela
>- jeśli istnieje **referencja mutowalna**, to ona ma wyłączny dostęp do wartości, nawet właściciel nie ma prawa modyfikacji wartości, aż do momentu zniknięcia referencji mutowalnej 


```rust
use std::collections::HashMap;

type Table = HashMap<String, Vec<String>>; // nie jest typem kopiowalnym, jest właścicielem dybanuczbue alokowanej struktury



fn show(table: Table) {
	for (artist, works) in table {
		println!("Mistrz {} i jego dzieła:", artist); 
		for work in works {
			println!(" {}", work); }
	} 
}

fn main(){
	let mut table = Table::new();
	table.insert("Gesualdo".to_string(), vec!["madrygały".to_string(), "Tenebrae Responsoria".to_string()]);

	show(table) ; //  `table` stanie się niezainicjalizowana, ponieważ funkcja przejmie własność nad danymi zawartymi w `table`
	// tak samo wewnętrzne `for`y funkcji będa przejmowały własność
}
```

```rust
fn show(table: &Table) {
	for (artist, works) in table {
	println!("Mistrz {} i jego dzieła:", artist); 
		for work in works {
			println!(" {}", work); }
	} 
}
```
==zamiast przekazania przez wartość (co wiąże się z przeniesieniem własności do funkcji) przekazujemy referencję współdzieloną==

```rust
fn sort_works(table: &mut Table) {
	for (_artist, works) in table {
		works.sort();
	}
}
```

`table: &mut Table` daje funkcji prawo do odczytu i zapisu struktury.

-----------
# Stosowanie referencji
Ogólnie, referencje pozwalają przekazywać do funkcji wartości, które:
- mogą być odczytane,
- mogą być modyfikowane
- własność nie jest przenoszona do funkcji.

Bardziej elastyczne zastosowania:


## Referencje Rusta kontra referencje C++
- niskopoziomowo referencje w C++ i Rust to po prostu **adres wskazujący wartość w pamięci**
- w C++ referencje tworzone niejawnie, odwoływanie się do nich też jest niejawne
- w Rust referencje (współdzielone) tworzone jawnie (operator `&`), odwołanie do wartości też jest jawne (operator `*`)

```rust
let x = 10;
let r = &x; // &x to referencja współdzielona do x

assert!(*r == 10); // Jawne odwołanie do wartości wskazywanej przez referencję

let mut y = 32;

let m = &mut y; // &mut y to mutowalna referencja do y
*m += 32;// Odwołanie za pomocą referencji m i zmiana wartości|

assert!(*m == 64); // Sprawdzenie aktualnej wartości *m, czyli y

```

>[!important] operator `.` - wyjątek
> - `referencja.wartość` - jeżeli Rust napotka referencję z lewej strony automatycznie będzie odwoływał się do wartości (prawa strona),
> -  Makro `println!`, z którego korzystamy w funkcji show, rozwijane jest do takiej postaci kodu, w której używany jest operator ., więc opisany mechanizm automatycznej dereferencji zadziała.
> - operator `.`, który automatycznie i ==niejawnie== potrafi stworzyć referencję i z niej skorzystać.

```rust
let mut v = vec![1973, 1968];

v.sort(); // Niejawnie pożycza mutowalną referencję do v
(&mut v).sort(); // To samo w wersji pełnej
```


## Referencje a operacje przypisania
- operacja przypisania referencji do zmiennej spowoduje, że zmienna będzie wskazywać nową wartość
```rust
let x = 10 ;
let y = 20 ;
let mut r = &x ;

if b {r=&y ;} // Referencja r wskazuje początkowo na zmienną x. Ale jeśli spełniony zostanie warunek b, to r zacznie być referencją do zmiennej y

assert!(*r == 10 || *r == 20) ;
```


## Referencja do referencji
Rust zezwala na tworzenie referencji do referencji:
```rust
struct Point {x: i32, y: i32}
let p = Point(x: 1000, y: 721) ;
let r: &Point = &p ;
let rr: &&Point = &r;
let rrr: &&&Point = &rr;

assert_eq!(rrr.y, 729); // operator `.` przechodzi przez kolejne referencje, by dotrzeć w końcu do celu
```
 


## Porównywanie referencji
nie tylko operator `.` „widzi” przez dowolną liczbę referencji, ale tak samo operatory porównania
```rust
let x = 10; let y = 10;
let rx = &x; let ry = &y;
let rrx = ℞ let rry = &ry;

assert!(rrx <= rry);
assert!(rrx == rry);


// jeśli chcesz porówna dwie referencje, a nie wartości:
std::ptr::eq 
assert!(rx == ry); // Wartości są równe
assert!(!std::ptr::eq(rx, ry)); // Ale adresy są różne

```


## Referencje nigdy nie są puste
- ==W języku Rust referencje nigdy nie są puste.==
- ==. Zmienna referencyjna musi być zainicjalizowana od razu.==

`Option<&T>` - ten typ pozwala opanować sytuację, w której wynikiem operacji będzie albo referencja do jakiejś wartości, albo informacja, że ona nie istnieje:
- `None` odpowiednik wartości pustekj
- `Some(r)` wartość istnieje (`r` jest typu `&T`)
W ten sposób Rust wymusza sprawdzenie istnienia wartości przed jej użyciem!!!!

## referencje do wyrażeń
W Rust można tworzyć referencje do wartości dowolnego praktycznie typu.

> [!definition] **Arithmetic Operations with References**
>- Rust has a unique feature where it allows you to perform arithmetic operations directly with references, thanks to the way operator overloading is implemented in the standard library. 
>- This means that you can add, subtract, multiply, etc., using references to values, rather than the values themselves.

>[!definition] Dereferencing and Auto-Dereferencing
>- When you use an operator like `+`, Rust automatically dereferences the operands if they are references, so you don't have to manually dereference them using `*`. 
>- This makes the code more ergonomic and avoids cluttering it with explicit dereferencing.

```rust
fn factorial(n: usize) -> usize { 
	(1..n+1).product()
}

let r = &factorial(6);

// Operatory arytmetyczne potrafią odwoływać się do wartości przy użyciu referencji
assert_eq!(r + &1009, 1729); // RUst twor
```







