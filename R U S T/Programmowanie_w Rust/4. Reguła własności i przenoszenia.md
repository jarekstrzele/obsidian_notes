[[_ Programowanie w języku Rust]]

CHODZI O ŚCISŁE I RESTRYKCYJNE ZASADY POSŁUGIWANIA SIĘ WSKAŹNIKAMI.

# Reguła własności

- każda wartość ma jednego właściciela,
- usunięcie właściciela `-->` usunięcie wartość tego właściciela,
	- *Kiedy sterowanie wychodzi z zasięgu bloku, w którym zmienna była zadeklarowana, zmienna jest usuwana i jej bufor automatycznie też.*

```rust
 fn print_padovan() {
    let mut padovan = vec![1, 1, 1]; // Alokacja zmiennej on the heap
    // vectors store their elements in heap memory
    // the vector itself (its size, capacity, pointer to the heap data) is stored on the stack
    for i in 3..10 {
	    let next = padovan[i - 3] + padovan[i - 2];
		padovan.push(next);
    }
    println!("P(1..10) = {:?}", padovan); /// P(1..10) = [1, 1, 1, 2, 2, 3, 4, 5, 7, 9]
// the macro println! takes a reference to 'padavan' and prints its contents; Rust automatically borrows `padavan` immutably for this operation

} // Usunięcie zmiennej

fn main() {
   print_padovan();
}
```

`Box::new`
```rust
fn main() {
    let point = Box::new((0.625, 0.5)); // Alokacja punktu
    let label = format!("{:?}", point); // Alokacja etykiety 
    println!("{:?}", label) ; // "(0.625, 0.5)"
}
```

`point`:
- is a smart pointer, the `Box` is allocated on the stack
- the tuple `(0.625, 0.5)` is allocated on the heap


```rust
struct Person { name: String, birth: i32 } let mut composers = Vec::new();

composers.push(Person { name: "Palestrina".to_string(), birth: 1525 }); 
composers.push(Person { name: "Dowland".to_string(), birth: 1563 }); 
composers.push(Person { name: "Lully".to_string(), birth: 1632 });

for composer in &composers {
	println!("{}, urodzony {}", composer.name, composer.birth); 
}
```

![[Pasted image 20240820213048.png]]

> zmienna `composers` jest właścicielem `wektora`, 
> > `wektor` posiada swoje elementy, z których każdy jest `strukturą` typu `Person`,
> > > a każda `struktura` ma swoje `pola`, w tym pole tekstowe, które jest właścicielem zawartego w nim tekstu. 
> wektor `composers` jest WŁAŚCICIELEM wszystkich swoich elementów
> Gdy sterowanie opuszcza zakres, w którym zadeklarowana jest zmienna `composers`, program **usuwa** ją i wraz z nią cały układ powiązanych wartości.

















