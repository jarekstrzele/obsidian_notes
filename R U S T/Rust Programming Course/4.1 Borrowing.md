#rust/borrowing 

>[!important] Borrowing
>Establishing a ==reference== to some data:
>- just like pointers with some rules
>- does not take ownership
> 
> ==why borrowing==
> - prevent unnecessary memory usage
> - ownership not required
>  
> ==rules==
> - at any time, you can have either one mutable reference or any number of immutable references
> - references must always be valid
> it solve out: data race, dangling references

```rust
  let mut vec_1: Vec<i32> = vec![4,5,6] ;
  //let ref1: &mut Vec<i32> = &mut vec_1;
  //let ref2: &mut Vec<i32> = &mut vec_1; //error can;t have to mutable references
  let ref1: &Vec<i32> = &vec_1;
  //let ref2: &mut Vec<i32> = &mut vec_1; //error can;t have to mutable references
  let ref2: &Vec<i32> = &vec_1;
  
  
  println!("ref1: {:?}, ref1: {:?}, ref2: {:?}", ref1, ref1, ref2) ;
```

```rust
fn main() {
  let mut vec_1: Vec<i32> = vec![4,5,6] ;
  let ref1: &Vec<i32> = &vec_1;
  //let ref2: &mut Vec<i32> = &mut vec_1; //error can;t have to mutable references
  let ref2: &Vec<i32> = &vec_1;
  println!("ref1: {:?}, ref2: {:?}", ref1, ref2) ;
  // end of the scope for immutable refrences
  
  let ref3: &mut Vec<i32> = &mut vec_1 ;
  println!("ref3: {:?}", ref3) ;
}

```


```
ref1: [4, 5, 6], ref2: [4, 5, 6]
ref3: [4, 5, 6]
```



# Borrowing in functions



















