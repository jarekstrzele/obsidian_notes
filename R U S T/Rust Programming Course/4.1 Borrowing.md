#rust/borrowing 

>[!important] Borrowing
>Establishing a ==reference== to some data:
>- just like pointers with some rules
>- does not take ownership
> 
> ==why borrowing==
> - prevent unnecessary memory usage
> - ownership not required
>  
> ==rules==
> - at any time, you can have either one mutable reference or any number of immutable references
> - references must always be valid
> it solve out: data race, dangling references

```rust
  let mut vec_1: Vec<i32> = vec![4,5,6] ;
  //let ref1: &mut Vec<i32> = &mut vec_1;
  //let ref2: &mut Vec<i32> = &mut vec_1; //error can;t have to mutable references
  let ref1: &Vec<i32> = &vec_1;
  //let ref2: &mut Vec<i32> = &mut vec_1; //error can;t have to mutable references
  let ref2: &Vec<i32> = &vec_1;
  
  
  println!("ref1: {:?}, ref1: {:?}, ref2: {:?}", ref1, ref1, ref2) ;
```

```rust
fn main() {
  let mut vec_1: Vec<i32> = vec![4,5,6] ;
  let ref1: &Vec<i32> = &vec_1;
  //let ref2: &mut Vec<i32> = &mut vec_1; //error can;t have to mutable references
  let ref2: &Vec<i32> = &vec_1;
  println!("ref1: {:?}, ref2: {:?}", ref1, ref2) ;
  // end of the scope for immutable refrences
  
  let ref3: &mut Vec<i32> = &mut vec_1 ;
  println!("ref3: {:?}", ref3) ;
}

```


```
ref1: [4, 5, 6], ref2: [4, 5, 6]
ref3: [4, 5, 6]
```



# Borrowing in functions
```rust


fn main() {
  
  let vec_1: Vec<i32> = vec![1,2,3] ;
  let ref1: &Vec<i32> = &vec_1 ; 
  borrow_vec(ref1) ;
  println!("vec_1 {:?}", vec_1);
}

fn borrow_vec(vec: &Vec<i32>){
    println!("borrow_vec {:?}", vec) ;
}

```

```
borrow_vec [1, 2, 3]
vec_1 [1, 2, 3]
```


```rust
fn main() {
  
  let mut my_vec: Vec<i32> = vec![10,20,30] ;
  
  println!("my vec: {:?}", my_vec);
  mutably_borrows_vec(&mut my_vec) ;  
  println!("my vec: {:?}", my_vec);
    
}

fn mutably_borrows_vec(v: &mut Vec<i32>){
    v.push(30) ;
}
```

```
my vec: [10, 20, 30]
my vec: [10, 20, 30, 30]
```












