# Koncepcja aplikacji

Aplikacja będzie prostym kalkulatorem, który pozwoli na dodawanie, odejmowanie, mnożenie i dzielenie. Użytkownik będzie mógł wprowadzić operację przez wiersz poleceń, a aplikacja wyświetli wynik.

# Struktura projektu

1. **Moduły**: Podzielimy kod na moduły, aby utrzymać porządek.
2. **Enum**: Zdefiniujemy enum `Operation` dla operacji matematycznych.
3. **Struct**: Utworzymy strukturę `Calculator` do przechowywania stanu i logiki.
4. **Smart Pointers**: Wykorzystamy `Arc` oraz `RefCell` do zarządzania współdzielonym stanem w bezpieczny sposób.


# `mod.rs`
```rust
pub struct Calculator;

impl Calculator {
	pub fn new() -> Self{
		Calculator
}

	pub fn evaluate(&mut self, expression: &str) -> Result<f64, String> {

	let tokens: Vec<&str> = expression.trim().split_whitespace().collect();

	if tokens.len() != 3 {
		return Err("Please enter a valid operation (e.g., 5 + 3)".into());
	}

	let num1 = tokens[0].parse::<f64>().map_err(|_| "Invalid number")?;
	let num2 = tokens[2].parse::<f64>().map_err(|_| "Invalid number")?;

	match tokens[1] {
		"+" => Ok(num1 + num2),
		"-" => Ok(num1 - num2),
		"*" => Ok(num1 * num2),
		"/" => {
			if num2 == 0.0 {
				Err("Cannot divide by zero".into())
			} else {
				Ok(num1 / num2)
			}
		},
		_ => Err("Invalid operator".into()),
	}
	}
}
```


## Wyjaśnienia

`impl Calculator {...` oznacza, że będą implementowane metody dla struktur `Calculcator`
```rust
impl Calculator {
    pub fn new() -> Self{
        Calculator
    }
}

```

- Sygnatura funkcji `pub fn new() -> Self`,
- ciało funkcji `{ Calculator } `  - W Rust, ostatnie wyrażenie w ciele funkcji jest automatycznie zwracane bez potrzeby używania słowa kluczowego `return`. Tak więc `Calculator` jest tutaj zwracany jako wartość funkcji.
- tworzenie instancji struktury `struct Point {x: i32}` przez inicjalizację jego pola `let p = Point { x: 23 };`
- tworzenie instancji struktury `struct Point`, która jest pusta `let p = Point;`

prosty przykład
```rust
// mod.rs
pub struct Calculator;

impl Calculator {
    pub fn new() -> Self {
        Calculator
    }
}

// Użycie struktury
fn main() {
    let calc = Calculator::new();
    // Teraz masz nową instancję kalkulatora
}

```

#### deklaracja funkcji `evaluate`
```rust
pub fn evaluate(&mut self, expression: &str) -> Result<f64, String>
``` 
-  `&mut self`: Funkcja przyjmuje mutowalną referencję do siebie (`self`), co oznacza, że może zmieniać stan struktury `Calculator`.
- `expression: &str`: Funkcja przyjmuje jedną referencję do ciągu znaków (`&str`), który reprezentuje wyrażenie do obliczenia.
- `-> Result<f64, String>`: Funkcja zwraca `Result<f64, String>`, gdzie `Ok(f64)` oznacza poprawny wynik obliczeń, a `Err(String)` oznacza błąd z komunikatem.


#### Tokenizacja wyrażenia
```rust
let tokens: Vec<&str> = expression.trim().split_whitespace().collect();
```
- `expression.trim()`: usuwamy białe znaki z początku i końca wyrażenia.
- `split_whitespace()`: dzielimy wyrażenie na tokeny według białych znaków.
- `collect()`: zbieramy tokeny do wektora (`Vec<&str>`).


#### Sprawdzenie ilość tokenów
```rust
if tokens.len() != 3 {
    return Err("Please enter a valid operation (e.g., 5 + 3)".into());
}

```

> Funkcja `into()` w Rust jest metodą, która konwertuje jedną wartość na inną. Jest częścią standardowej biblioteki Rust i jest szeroko stosowana do konwersji między różnymi typami. W kontekście Twojego kodu, `into()` jest używane do konwersji ciągu znaków (`&str`) na `String`.

#### parsowanie
```rust
let num1 = tokens[0].parse::<f64>().map_err(|_| "Invalid number")?;
let num2 = tokens[2].parse::<f64>().map_err(|_| "Invalid number")?;
```

- `tokens[0].parse::<f64>()`: Parsujemy pierwszy token jako `f64`. Jeśli parsowanie się nie powiedzie, zwracamy błąd "Invalid number".
- `tokens[2].parse::<f64>()`: Parsujemy trzeci token jako `f64`. Jeśli parsowanie się nie powiedzie, zwracamy błąd "Invalid number".











