# Koncepcja aplikacji

Aplikacja będzie prostym kalkulatorem, który pozwoli na dodawanie, odejmowanie, mnożenie i dzielenie. Użytkownik będzie mógł wprowadzić operację przez wiersz poleceń, a aplikacja wyświetli wynik.

# Struktura projektu

1. **Moduły**: Podzielimy kod na moduły, aby utrzymać porządek.
2. **Enum**: Zdefiniujemy enum `Operation` dla operacji matematycznych.
3. **Struct**: Utworzymy strukturę `Calculator` do przechowywania stanu i logiki.
4. **Smart Pointers**: Wykorzystamy `Arc` oraz `RefCell` do zarządzania współdzielonym stanem w bezpieczny sposób.


# `calculator/mod.rs`
```rust
pub struct Calculator;

impl Calculator {
	pub fn new() -> Self{
		Calculator
}

	pub fn evaluate(&mut self, expression: &str) -> Result<f64, String> {

	let tokens: Vec<&str> = expression.trim().split_whitespace().collect();

	if tokens.len() != 3 {
		return Err("Please enter a valid operation (e.g., 5 + 3)".into());
	}

	let num1 = tokens[0].parse::<f64>().map_err(|_| "Invalid number")?;
	let num2 = tokens[2].parse::<f64>().map_err(|_| "Invalid number")?;

	match tokens[1] {
		"+" => Ok(num1 + num2),
		"-" => Ok(num1 - num2),
		"*" => Ok(num1 * num2),
		"/" => {
			if num2 == 0.0 {
				Err("Cannot divide by zero".into())
			} else {
				Ok(num1 / num2)
			}
		},
		_ => Err("Invalid operator".into()),
	}
	}
}
```


## Wyjaśnienia

`impl Calculator {...` oznacza, że będą implementowane metody dla struktur `Calculcator`
```rust
impl Calculator {
    pub fn new() -> Self{
        Calculator
    }
}

```

- Sygnatura funkcji `pub fn new() -> Self`,
- ciało funkcji `{ Calculator } `  - W Rust, ostatnie wyrażenie w ciele funkcji jest automatycznie zwracane bez potrzeby używania słowa kluczowego `return`. Tak więc `Calculator` jest tutaj zwracany jako wartość funkcji.
- tworzenie instancji struktury `struct Point {x: i32}` przez inicjalizację jego pola `let p = Point { x: 23 };`
- tworzenie instancji struktury `struct Point`, która jest pusta `let p = Point;`

prosty przykład
```rust
// mod.rs
pub struct Calculator;

impl Calculator {
    pub fn new() -> Self {
        Calculator
    }
}

// Użycie struktury
fn main() {
    let calc = Calculator::new();
    // Teraz masz nową instancję kalkulatora
}

```

#### deklaracja funkcji `evaluate`
```rust
pub fn evaluate(&mut self, expression: &str) -> Result<f64, String>
``` 
-  `&mut self`: Funkcja przyjmuje mutowalną referencję do siebie (`self`), co oznacza, że może zmieniać stan struktury `Calculator`.
- `expression: &str`: Funkcja przyjmuje jedną referencję do ciągu znaków (`&str`), który reprezentuje wyrażenie do obliczenia.
- `-> Result<f64, String>`: Funkcja zwraca `Result<f64, String>`, gdzie `Ok(f64)` oznacza poprawny wynik obliczeń, a `Err(String)` oznacza błąd z komunikatem.


#### Tokenizacja wyrażenia
```rust
let tokens: Vec<&str> = expression.trim().split_whitespace().collect();
```
- `expression.trim()`: usuwamy białe znaki z początku i końca wyrażenia.
- `split_whitespace()`: dzielimy wyrażenie na tokeny według białych znaków.
- `collect()`: zbieramy tokeny do wektora (`Vec<&str>`).


#### Sprawdzenie ilość tokenów
```rust
if tokens.len() != 3 {
    return Err("Please enter a valid operation (e.g., 5 + 3)".into());
}

```

> Funkcja `into()` w Rust jest metodą, która konwertuje jedną wartość na inną. Jest częścią standardowej biblioteki Rust i jest szeroko stosowana do konwersji między różnymi typami. W kontekście Twojego kodu, `into()` jest używane do konwersji ciągu znaków (`&str`) na `String`.

#### parsowanie
#rust/parse
```rust
let num1 = tokens[0].parse::<f64>().map_err(|_| "Invalid number")?;
let num2 = tokens[2].parse::<f64>().map_err(|_| "Invalid number")?;
```

- `tokens[0].parse::<f64>()`: Parsujemy pierwszy token jako `f64`. Jeśli parsowanie się nie powiedzie, zwracamy błąd "Invalid number".
- `tokens[2].parse::<f64>()`: Parsujemy trzeci token jako `f64`. Jeśli parsowanie się nie powiedzie, zwracamy błąd "Invalid number".
- `map_err(|_| "Invalid number")` - - **`|_| "Invalid number"`**: Jest to anonimowa funkcja (closure), która przyjmuje jeden argument (w naszym przypadku niewykorzystany `_`, ponieważ nie interesuje nas szczegółowy błąd) i zwraca `String` o wartości `"Invalid number"`.
		Co dokładnie robi `map_err`:
			- **`|_|`**: Ignoruje oryginalny błąd (nie potrzebujemy informacji o szczegółach błędu parsowania).
			- **`"Invalid number"`**: Tworzy nowy `String` z naszym własnym komunikatem błędu.
		- `?` Operator `?` w Rust jest używany do propagacji błędów. Jeśli wynik wywołania metody `parse` jest `Ok`, wartość zostanie wyciągnięta z `Ok` i przypisana do `num2`. Jeśli wynik jest `Err`, błąd zostanie natychmiast zwrócony z bieżącej funkcji, a dalsze wykonywanie funkcji zostanie przerwane. 


Operator `?` w Rust jest używany do propagacji błędów. Jeśli wynik wywołania metody `parse` jest `Ok`, wartość zostanie wyciągnięta z `Ok` i przypisana do `num2`. Jeśli wynik jest `Err`, błąd zostanie natychmiast zwrócony z bieżącej funkcji, a dalsze wykonywanie funkcji zostanie przerwane.

---------

`main.rs`
```rust
mod calculator;

use calculator::Calculator;
use std::sync::{Arc, Mutex};
// use std::cell::RefCell;
use std::io;
use std::thread;
  

fn main() {
	let calc = Arc::new(Mutex::new(Calculator::new()));

	loop {
		loop {
			println!("Enter operation (e.g., 1 + 1) or 'exit' to quit:");
			let mut input = String::new();

io::stdin().read_line(&mut input).expect("Failed to read line");

if input.trim() == "exit" {

break;

}

let calc_clone = Arc::clone(&calc);

thread::spawn(move || {

let mut calc = calc_clone.lock().unwrap();

let result = calc.evaluate(&input);

match result {

Ok(n) => println!("Result: {}", n),

Err(e) => println!("Error: {}", e),

}

}).join().unwrap();

}

}

}
```






