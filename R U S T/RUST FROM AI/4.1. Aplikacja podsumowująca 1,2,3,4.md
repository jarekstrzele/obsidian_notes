# Koncepcja aplikacji

Aplikacja będzie prostym kalkulatorem, który pozwoli na dodawanie, odejmowanie, mnożenie i dzielenie. Użytkownik będzie mógł wprowadzić operację przez wiersz poleceń, a aplikacja wyświetli wynik.

# Struktura projektu

1. **Moduły**: Podzielimy kod na moduły, aby utrzymać porządek.
2. **Enum**: Zdefiniujemy enum `Operation` dla operacji matematycznych.
3. **Struct**: Utworzymy strukturę `Calculator` do przechowywania stanu i logiki.
4. **Smart Pointers**: Wykorzystamy `Arc` oraz `RefCell` do zarządzania współdzielonym stanem w bezpieczny sposób.


# wstępne wyjaśnienia

`impl Calculator {...` oznacza, że będą implementowane metody dla struktur `Calculcator`


```rust
impl Calculator {
    pub fn new() -> Self{
        Calculator
    }
}

```

- sygnatura funkcji `pub fn new() -> Self`,
- ciało funkcji `{ Calculator } `  - W Rust, ostatnie wyrażenie w ciele funkcji jest automatycznie zwracane bez potrzeby używania słowa kluczowego `return`. Tak więc `Calculator` jest tutaj zwracany jako wartość funkcji.
- tworzenie instancji struktury `struct Point {x: i32}` przez inicjalizację jego pola `let p = Point { x: 23 };`
- tworzenie instancji struktury `struct Point`, która jest pusta `let p = Point;`

prosty przykład
```rust
// mod.rs
pub struct Calculator;

impl Calculator {
    pub fn new() -> Self {
        Calculator
    }
}

// Użycie struktury
fn main() {
    let calc = Calculator::new();
    // Teraz masz nową instancję kalkulatora
}

```


```rust
pub fn evaluate(&mut self, expression: &str) -> Result<f64, String>
``` 
-  `&mut self`: Funkcja przyjmuje mutable referencję do siebie (`self`), co oznacza, że może zmieniać stan struktury `Calculator`.







