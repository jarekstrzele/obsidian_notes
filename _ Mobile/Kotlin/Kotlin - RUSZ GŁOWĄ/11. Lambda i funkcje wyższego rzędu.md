#kotlin/lambda_function 

[[_ 0 Kotlin Rusz Głową]]

>[!danger] wyrażenie lambda
>- typ obiektu zwierający blok kodu
>- może być zapisana w zmiennej,
>- może być przekazana do funkcji, która wykona kod zawarty w lambda
>- lambda można używać do przekazywania konkretnych zachowań do bardziej ogólnych funkcji - np:
>> 	- obiekt `MutableList` ma metodę `sortBy()`, która zna ogólny sposób sortowania
>> 	- przekazując funkcję lambda do `sortBy()` określamy konkretny sposób sortowania


# syntaktyka

jeden parametr:
`{ x: Int -> x + 5 }` do przekazanego parametru typu `Int` dodaje wartość `5` 

` { } ` otwierają i zamykają wyrażenie lambda

> Wszystkie lambdy są definiowane w nawiasach klamrowych, których nie można pomijać.

wiele parametrów
`{x: Int, y: Int - > x + y }`

==Jeśli wyrażenie lambda nie ma żadnych parametrów, to symbol -> można pominąć==
`{ "Hau!" }` wyrażenie lambda bez parametrów


ZAPISYWANIE LAMBDY W ZMIENNYCH
`val addFive = {x: Int -> x+5}`

WYKONYWANIE KODU LAMBDY POPRZEZ JEJ WYWOŁANIE
```kotlin
val addInts = {x: Int, y: Int -> x + y}
val result = addInts.invoke(6,7)
// LUB skrócona wersja
val result2 = addInts(6,7)

```


>[!tip] typ funkcyjny
>- typ wyrażenia lambda
>- `(parametry) -> typ_wyniku` 

```kotlin
val msg = { x:Int -> "Wartością jest: $x."}
// typem funkcji msg jest (Int)->String

val add: (Int, Int) -> Int //jawne określenie typu
add = {x: Int, y: Int -> x+y}

val greeting: ()->String //jawne określenie typu
greeting = {"Czołem"}

// zmienna      typ           wartość
val greeting: ()->String = { "Czołem" }
```

## Kompilator może wywnioskować typ parametrów lambdy
> W razie jawnego deklarowania typu zmiennej w wyrażeniu lambda możemy pominąć wszelkie deklaracje typów, które kompilator może samodzielnie wywnioskować.
`val addFive: (Int)->Int = {x -> x+5}` kompilator wie, że `x` musi być typu `Int` , dlatego możemy pominą jego jawne określenie `{x:Int-> x+5}`


## Pojedynczy parametr możemy zastąpić `it`
Jeśli dysponujemy **wyrażeniem lambda** mającym:
- pojedynczy parametr, 
- typ parametru kompilator może samodzielnie wywnioskować,
to deklarację tego parametru możemy pominąć, a w ciele lambdy możemy odwoływać się do niego, używając słowa kluczowego`it`.
```kotlin
val addFive: (Int) -> Int = { x -> x + 5 }
// można zastąić
val addFive: (Int) -> Int = { it + 5 }

//ten kod nie spełnia w/w warunków, więc się nieskompiluje
val addFive = { it + 5 } //Tej instrukcji nie uda się skompilować, gdyż kompilator nie potrafi określić typu parametru
```


## Używaj lambdy dostosowanej do typu zmiennej.

```kotlin
val calculation: (Int, Int) -> Int

calculation = { x: Double, y: Double -> x + y } // Tej instrukcji nie uda się skompilować, gdyż w zmiennej calculation można zapisać wyłącznie wyrażenie lambda mające dwa parametry typu Int i zwracające wynik typu Int.
```

### `Unit` - użyj tego typu, jeśli lambda niczego nie zwraca.
##### `val myLambda: () -> Unit = { println(”Cześć!”) }`

>[!tip] `let`
>`let` jest funkcją, której parametrem jest wyażenie lambda.


## Możesz przekazać lambdę do funkcji.

>[!definition] funkcja wyższego rzędu
>Funkcję, której parametrem jest wyrażenie lambda, nazywamy funkcją wyższego rzędu.
>
>Takie rozwiązanie pozwala przekazywać konkretne zachowania do bardziej ogólnych funkcji.

```kotlin
fun main(){  
  
    convert(20.0, {c: Double -> c*1.8+32})  
  
}  
  
fun convert(x:Double,  
            converter: (Double)->Double):Double{  
    val result = converter(x)  
    println("Wartość $x została przekształcona na wartość: $result")  
  
    return result  
}
```












