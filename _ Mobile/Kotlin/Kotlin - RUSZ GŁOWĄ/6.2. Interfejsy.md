[[6.1 Klasy abstrakcyjne]]
[[_ 0 Kotlin Rusz Głową]]

> Jeśli dwie klasy nie spełniają testu JEST, to najprawdopodobniej nie należą do hierarchii tej samej klasy bazowej.

```kotlin
// WSPÓLNE ZACHOWANIE `roam`, ale nie spełniony test JEST
abstract class Animal {
	//...
	abstract fun roam()
}

class Vehicle {
	fun roam() {}
}
```

>[!definition] INTERFEJS
> - Kiedy mamy niezależne od siebie klasy dysponujące wspólnym zachowaniem, to zachowanie to można zamodelować w formie interfejsu
> - Intefejsy pozwalają definiować wspólne zachowania POZA hierarchią klasy bazowej
> - interfejsy NIE MOGĄ DEFINIOWAĆ KONSTRUKTORÓW




>[!danger] Ważna informacja
>klasa może implementować dowolnie wiele interfejsów, lecz może mieć tylko jedną bezpośrednią klasę bazową.

## Funkcje w interfejach
```kotlin
interface Roamble {
	fun roam() // to jest ABSTRAKCYJNA metoda

	// w interfejsie można dodawać KONKRETNE metody
	fun roam2(){
		println("Wałęsające się coś.")
	}
}
```


## Właściwości w interfejsach
```kotlin
interface Roamble{
	val velocity: Int // to jest właściwość abstrakcyjna
}
```

istnieje możliwość zwracania wartości właściwości
```kotlin
interface Roamble{
	val velocity: Int // to jest właściwość abstrakcyjna
		get() = 20
}
```

w interfejscach nie ma pola wspierającego `field`, ale można zdefiniować `set`, choć bez modyfikacji wartości właściwości:
```kotlin
interface Roamble{
	val velocity: Int // to jest właściwość abstrakcyjna
		get() = 20
		set(value){
			//field = value //nie zadziała
			println("Nie możńa zmienić wartości właściwości!!!")
		}
}
```

>[!inf] pole wspierające `field`
>pole wspierające pozwala na przechowywanie referencji do wartości właściwości.

## implementacja interfejsu
```kotlin
class Vehicle : Roamble{

}
```
==po nazwie interfejsu NIE UMIESZCZA SIĘ `()`==, bo interfejsy nie mają konstruktorów

> zadeklarowanie, że klasa implementuje interfejs, daje jej wszystkie właściwości i funkcje dostępne w interjesie
> 
> Dowolne z tych właściwości i funkcji można przesłonić, przy czym robi się to w dokładnie taki sam sposób, w jaki są przesłaniane właściwości i funkcje odziedziczone po klasie bazowej.
> 
> ==Klasa konkretna nie może zawierać żadnych abstrakcyjnych właściwości lub funkcji==, dlatego też wszystkie abstrakcyjne właściwości i funkcje muszą w niej zostać zaimplementowane.
> 

```kotlin
class Vehicle : Roamble {
	override fun roam(){
		println("Pojazd wałęsa się ...")
	}
}
```

### Implementacja wielu interfejsów
```kotlin
class X : A, B {

}
```

```kotlin
class Y: C(), A{

}
```

>[!important] Reguła, gdy występuje ta sama funkcja lub właściwość:
Gdy klasa dziedziczy wiele implementacji TEJ SAMEJ funkcji lub właściwości, to musi dostarczyć jej własną implementację bądź też wskazać, która wersja właściwości lub funkcji ma być używana
```kotlin
// najpierw wykonana zostanie myFunction z interfejsu A, potem z interfejsu B, a potem z klasy X
class X : A, B {
	override fun myFunction(){
		super<A>.myFunction()
		super<B>.myFunction()
		// kod charakterystyczny dla klasy X
	}

}
```










