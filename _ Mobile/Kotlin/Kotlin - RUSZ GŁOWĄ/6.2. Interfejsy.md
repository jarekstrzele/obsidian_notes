[[6.1 Klasy abstrakcyjne]]
[[_ 0 Kotlin Rusz Głową]]

> Jeśli dwie klasy nie spełniają testu JEST, to najprawdopodobniej nie należą do hierarchii tej samej klasy bazowej.

```kotlin
// WSPÓLNE ZACHOWANIE `roam`, ale nie spełniony test JEST
abstract class Animal {
	//...
	abstract fun roam()
}

class Vehicle {
	fun roam() {}
}
```

>[!definition] INTERFEJS
> - Kiedy mamy niezależne od siebie klasy dysponujące wspólnym zachowaniem, to zachowanie to można zamodelować w formie interfejsu
> - Intefejsy pozwalają definiować wspólne zachowania POZA hierarchią klasy bazowej
> - interfejsy NIE MOGĄ DEFINIOWAĆ KONSTRUKTORÓW




>[!danger] Ważna informacja
>klasa może implementować dowolnie wiele interfejsów, lecz może mieć tylko jedną bezpośrednią klasę bazową.

## Funkcje w interfejach
```kotlin
interface Roamble {
	fun roam() // to jest ABSTRAKCYJNA metoda

	// w interfejsie można dodawać KONKRETNE metody
	fun roam2(){
		println("Wałęsające się coś.")
	}
}
```


## Właściwości w interfejsach
```kotlin
interface Roamble{
	val velocity: Int // to jest właściwość abstrakcyjna
}
```

istnieje możliwość zwracania wartości właściwości
```kotlin
interface Roamble{
	val velocity: Int // to jest właściwość abstrakcyjna
		get() = 20
}
```

w interfejscach nie ma pola wspierającego `field`, ale można zdefiniować `set`, choć bez modyfikacji wartości właściwości:
```kotlin
interface Roamble{
	val velocity: Int // to jest właściwość abstrakcyjna
		get() = 20
		set(value){
			//field = value //nie zadziała
			println("Nie możńa zmienić wartości właściwości!!!")
		}
}
```

>[!inf] pole wspierające `field`
>pole wspierające pozwala na przechowywanie referencji do wartości właściwości.



















