# Uruchamianie (`onStart())`, zatrzymywanie (`onStop())`), restartowanie (`onRestart()`)

> Aktywność jest **zatrzymana**, gdy jest
> - całkowicie przesłonięta przez inną aktywność i
> - nie jest widoczna dla użytkownika. 
>
>Taka aktywność:
>- **wciąż istnieje w tle** i 
>- **zachowuje wszystkie informacje** o swoim stanie.

> Wszystkie te metody (`onCreate, onDestroy, onStart, onStop, onRestart`) są dziedziczone po klasie `Activity`.

>[!info]  `onStart`
>wywoływana, gdy aktywność STAJE SIĘ widoczna dla użytkownika.


>[!info]  `onStop`
>wywoływana, gdy aktywność PRZESTAJE BYĆ widoczna dla użytkownika.


>[!info]  `onRestart`
>wywoływana, gdy aktywność jest już NIEWIDOCZNA, ale zostać PONOWNIE WYŚWIETLONA.


`onCreate()` -> `onStart()` - aktywność DZIAŁAJĄCA
`onStop()` -> `onRestart()` -> `onStart()` - aktywność DZIAŁAJĄCA
`onStop()` -> `onDestroy()` -> aktywność USUNIĘTA

> W przypadku przesłaniania metod cyklu życia naszych aktywności koniecznie musimy wywoływać metody klasy bazowej Activity. Jeśli tego nie zrobimy, Android zgłosi wyjątek.
> 

stoper zatrzymuje się, gdy aktywność staje się niewidoczna
```kotlin
override fun onStop() {  
	super.onStop()  
	running = false  
}
```

aby stoper aktywował liczenie po aktywacji aktywności:
```kotlin
  
class StopwatchActivity : Activity() {  
	private lateinit var timeView: TextView  
// Liczba sekund wyświetlana przez stoper  
	private var seconds = 0  
// Czy stoper działa?  
	private var running = false  

// nowy atrybut do zapamiętania stanu przed wyłączeniem stoper
private var wasRunning = false

//....
	override fun onCreate(savedInstanceState: Bundle?) {  
	super.onCreate(savedInstanceState)  
	setContentView(R.layout.activity_stopwatch)  
	timeView = findViewById(R.id.time_view)  
  
	if (savedInstanceState != null){  
	seconds = savedInstanceState.getInt("seconds")  
	running = savedInstanceState.getBoolean("running")  

	//wczytanie stanu przed schowaniem aktywności
	wasRunning = savedInstanceState.getBoolean("wasRunning")  
}  
  
runTimer()  
}

override fun onSaveInstanceState(savedInstanceState: Bundle) {  
super.onSaveInstanceState(savedInstanceState)  

savedInstanceState.putInt("seconds", seconds)  
savedInstanceState.putBoolean("running", running)  

//zapisanie stanu stopera przez schowaniem go
savedInstanceState.putBoolean("wasRunning", wasRunning)  
Log.i("save", "zapisano: $seconds, $running, wasRunning? $wasRunning")  
}

override fun onStop() {  
	super.onStop()  
	wasRunning = running  
	running = false  
  
}  
  
override fun onStart() {  
	super.onStart()  
	if (wasRunning){  
		running = true  
}  
}
```







