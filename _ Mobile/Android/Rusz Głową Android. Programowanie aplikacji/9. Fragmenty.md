[[_ Rusz Głową Android. Programowanie aplikacji]]

Twoja aplikacja musi wyglądać świetnie na wszystkich urządzeniach - potrzebujesz fragmentów

> Aby interfejsy aplikacji uruchomionej na tablecie i telefonie różniły się od siebie, możemy utworzyć odrębne pliki układów, które będą używane na dużych i na małych urządzeniach.

#android/fragment
>[!definition] Fragment
> - umożliwiają wielokrotne stosowanie kodu,
> - to rodzaj "podaktywności"/komponentu, który można wielokrotnie używać
> - służy do kontrolowania fragmentu ekranu i można go używać na wielu ekranach,
> - np. możemy stworzyć:
>> - fragment obsługujący listę treningów  i
>> - fragment wyświetlający szczegółowe informacje o wybranym treningu
>> - te fragmenty mogą być następnie używane w kilku układach.
>- każdy fragment ma swój układ

# apka na telefon
1. `MainActivity` będzie korzystała z fragmentu `WorkoutListFragment`.
2. `WorkoutListFragment` będzie wyświetlać listę wszystkich treningów.
3. `DetailActivity` uruchomiana aktywność, gdy kliknie się jeden z treningów, będzie zawierała fragment  `WorkoutDetailFragment`
4. oba fragmenty będą pobierały dane treningów  z pliku `Workout.kt`

## Cel:
1. UTWORZYĆ **aktywności** `MainActivity`, `DetailActivity`.
2. u tworzyć **fragment** `WorkoutDetailFragment` (będzie wyświetlać szczegółowe informacje o wybranym treningu).
3. dodać **fragment** z `2` do aktywności `DetailAcitivy` .
4. utworzyć **klasę** Kotlin `Workout.ks`, która będzie dostarczać danych używanych przez fragment `WorkoutDetailFragment`.
5. utworzyć **fragment** `WorkoutListFragment` (będzie prezentować listę treningów) - będzie dodany do `MainActivity`.
6. zapewnić KOORDYNACJĘ między fragmentami w celu wyświetlania odpowiedniego treningu.

`MainActivity` --> posłuży się fragmentem prezentującym listę treningów
`DetailActivity` --> posłuży się fragmentem do wyświetlania szegółowych informacji o konkretnym treningu.

## fragment `WorkoutDetailFragment`
>[!question] Jak dodać fragment do projektu?
>-  nowy fragment możemy dodać do projektu, podobnie jak dodajemy aktywności,
>- do fragmentu możemy dodawać dowolne widoki i układy, 
>- `File>New>Fragment`
>- wszystkie fragmenty muszą definiować publiczny konstruktor bezargumentowy
>> - Android używa tego konstruktora do tworzenia instancji fragmentu za każdym razem, gdy jest ona potrzebna
>> - jeśli zdefiniujesz własny konstruktor z argumentami, to również musisz dostarczyć konstruktor bezargumentowy, jeśli chcesz, aby fragment działał poprawnie w kontekście cyklu życia fragmentu w Androidzie.

### metoda `onCreateView()`
- ta metoda powstaje w pustym fragmencie,
- zwraca obiekt `View` reprezentujący interfejs użytkownika fragmentu
- jest wywoływana w momencie, gdy system Android jest gotów utworzyć interfejs użytkownika..

```kotlin
override fun onCreateView(  
	inflater: LayoutInflater, 
	container: ViewGroup?,  
	savedInstanceState: Bundle?  
): View? {  
// Inflate the layout for this fragment  
	return inflater.inflate(R.layout.fragment_workout_detail, container, false)  
}
```

`LayoutInflater` obiekt tego typu:
- jest używany do przygotowania układu fragmentu (`inflate` przygotowanie układu - oznacza przekształcenie widoków określonych w kodzie `XML` układu na obiekt Kotlina).
- używa metody `inflate()`, aby określić jaki układ ma mieć fragment:
	- pierwszy argument to układ fragmentu zapisany w `xml`, który zostanie przekształcony na obiekt Kotlina
	- drugi argument `container` określa obiekt `ViewGroup` z układu aktywności, w którym należy umieścić układ fragmentu,
	- trzeci argument `false` - Jeśli trzeci argument jest ustawiony na `false`, to utworzony widok jest zwracany, ale nie jest natychmiast dołączany do `container`. W takim przypadku musisz później ręcznie dołączyć ten widok, jeśli jest to wymagane.

`ViewGroup` obiekt tego typu reprezentuje układ aktywności (`ViewGroup`), który będzie zawierać fragment.

`Bundle` obiekt tego typu jest używany w sytuacji, kiedy wcześniej zapisaliśmy stan fragmentu i teraz chcemy go odtworzyć.

### fragment_workout_detail.xml`
do fragmentu dodaj dwa pola tekstowe *fragment_workou_detail.xml:
```xml
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
xmlns:tools="http://schemas.android.com/tools"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
tools:context=".WorkoutDetailFragment">  
  
<!-- TODO: Update blank fragment layout -->  
<TextView  
android:id="@+id/textTitle"  
android:layout_width="wrap_content"  
android:layout_height="wrap_content"  
android:text="@string/workout_title"  
android:textAppearance="?android:attr/textAppearanceLarge"  
/>  
  
<TextView  
android:id="@+id/textDescription"  
android:layout_width="wrap_content"  
android:layout_height="wrap_content"  
android:text="@string/workout_description"  
  
/>  
  
</LinearLayout>
```
> W przypadku `android:textAppearance="?android:attr/textAppearanceLarge"`, używane jest wbudowane wygląd tekstu o dużym rozmiarze, zdefiniowane w systemie Android. Wartość `?android:attr/textAppearanceLarge` odnosi się do zasobu stylu tekstu o dużym rozmiarze w atrybutach systemowych Androida.

### dodanie fragmentu do aktywności
do aktywności `DetailActivity`, czyli `activity_detail.xml`
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:name="com.js.trenazer.WorkoutDetailFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>

```

ponieważ w tej aktywności będzie tylko fragment całość można uprościć:

```xml
<?xml version="1.0" encoding="utf-8"?>  
<fragment  
	xmlns:android="http://schemas.android.com/apk/res/android"  
	android:name="com.js.trenazer.WorkoutDetailFragment"  	android:layout_width="match_parent"  
	android:layout_height="match_parent" 
/>  
```


>[!danger] ważne
> `AppCompatActivity` jest klasą pochodną `FragmentActivity`, więc jeśli tylko nasza aktywność dziedziczy po `AppCompatActivity`, fragmenty z biblioteki wsparcia będą działać.

### interakcja fragment-aktywność

#### utworzenie pliku klasy z danymi
utwórz plik klasy  `Workout.kt`, z którego dane będą używane w `WorkoutDetailFragment`
```kotlin
data class Workout(val name: String, val description: String)

class WorkoutRepository {
    companion object {
        val workouts = listOf(
            Workout("Rozciąganie kończyn", "5 pompek w staniu na rękach,\n10 przysiadów na jednej nodze,\n15 podciągnięć."),
            Workout("Ogólna agonia", "100 podciągnięć,\n100 pompek,\n100 brzuszków,\n100 przysiadów."),
            Workout("Tylko dla mięczaków", "5 podciągnięć,\n10 pompek,\n15 przysiadów."),
            Workout("Siła i dystans", "Bieg na 500 metrów,\n21 wydźwignięć ciężarka,\n21 podciągnięć.")
        )
    }
}

```

#### przekazanie identyfikatora treningu do fragmentu

> Kiedy aktywność używa fragmentu, to zazwyczaj musi w jakiś sposób się z nim komunikować. Na przykład, jeśli fragment prezentuje szczegółowe informacje o konkretnym rekordzie, to aktywność musi przekazać do niego informację o tym, który rekord ma zostać wyświetlony.

`WorkoutDetailFragment.kt`
```kotlin
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment

class WorkoutDetailFragment : Fragment() {

    private var workoutId: Long = 0

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_workout_detail, container, false)
    }

	//To jest metoda do ustawiania identyfikatora treningu. Aktywność będzie jej używać do określania identyfikatora treningu.
    fun setWorkout(id: Long) {
        this.workoutId = id
    }
}

```

dodaj do fragmentu id `detail_frag`:
```xml
<fragment  
android:id="@+id/detail_frag"  
xmlns:android="http://schemas.android.com/apk/res/android"  
android:name="com.js.trenazer.WorkoutDetailFragment"  
android:layout_width="match_parent"  
android:layout_height="match_parent" />
```

`DetailActivity.kt`
```kotlin
class DetailActivity : AppCompatActivity() {  
	override fun onCreate(savedInstanceState: Bundle?) {  
	super.onCreate(savedInstanceState)  
	setContentView(R.layout.activity_detail)  
  
	val frag = supportFragmentManager.findFragmentById(R.id.detail_frag) as WorkoutDetailFragment  
	frag.setWorkout(1)  
}  
}
```

`val frag = supportFragmentManager.findFragmentById(R.id.detail_frag) as WorkoutDetailFragment`: 
- Pobranie fragmentu o identyfikatorze `detail_frag` z menedżera fragmentów (`supportFragmentManager`). 
- Menedżer fragmentów zarządza cyklem życia fragmentów w aktywności. 
- Następnie rzutowanie go na typ `WorkoutDetailFragment`.

`frag.setWorkout(1)`: 
- Wywołanie metody `setWorkout(1)` na obiekcie `WorkoutDetailFragment`, gdzie `1` to pewna wartość przekazywana jako argument. 
- Metoda ta, być może, ustawia pewne informacje o treningu wewnątrz tego fragmentu.

#### Cykl życia fragmentu
>Jak już się przekonałeś, nasz fragment dziedziczy po systemowej klasie Fragment. Ta klasa zapewnia mu dostęp do metod cyklu życia fragmentu.

> [!danger] `Fragment` vs `Activity`
> Choć fragmenty mają całkiem sporo wspólnego z aktywnościami, to jednak klasa `Fragment` NIE DZIEDZICZY po `Activity`.
> Oznacza to, że niektóre spośród metod dostępnych w aktywnościach nie będą dostępne we fragmentach.

>[!danger] `Fragment` vs `Context`
>klasa `Fragment` NIE DZIEDZICZY po klasie `Context`.
>W odróżnieniu od aktywności fragmenty nie są jednym z typów kontekstu, a co za tym idzie, **nie mają bezpośredniego dostępu do globalnych informacji o środowisku aplikacji**.

> Implementując metody cyklu życia fragmentu, zawsze musisz wywoływać analogiczną metodę klasy bazowej.

![[Pasted image 20240131091457.png]]


#### implementacja `onStart()`
> Musimy zadbać o to, by nasz fragment `WorkoutDetailFragment` wyświetlał szczegółowe informacje o wybranym treningu. Operacja ta musi być wykonywana, kiedy aktywność staje się widoczna, dlatego zaimplementujemy ją w metodzie `onStart()` fragmentu

`WorkoutDetailFragment.kt`
```kotlin
...
override fun onStart() {  
	super.onStart()  
	val view = view  
	if (view != null) {  
	val title = view.findViewById<TextView>(R.id.textTitle)  
	val workout = WorkoutRepository.workouts[workoutId.toInt()]  
	title.text = workout.name  
	val description = view.findViewById<TextView>(R.id.textDescription)  
	description.text = workout.description  
	}  
}
```

>[!danger] ważne `val view = view`
>- fragmenty różnią się od aktywności i dlatego nie dysponują wszystkimi metodami, które mają aktywności. Na przykład fragmenty nie udostępniają metody `findViewById()`,
>- dlatego aby pobrać referencje do widoków fragmentu, musimy najpierw pobrać referencję do widoku głównego.

------------
## ListFragment -`WorkoutListFragment`

> Teraz musimy utworzyć drugi fragment, `WorkoutListFragment`, zawierający listę wszystkich treningów, które użytkownik może wybierać. 
> Zastosowanie fragmentu do tego celu oznacza, że później będziemy mogli go użyć, by utworzyć inny interfejs użytkownika aplikacji dla telefonów i dla tabletów.

>[!definition] `ListFragment`
> `ListFragment` jest typem fragmentu przystosowanym do korzystania z list. Dysponuje on domyślnym układem zawierającym pojedynczy komponent `ListView`.
> 
> Fragment listy dysponuje swoim własnym widokiem listy, dzięki czemu nie musimy sami tworzyć takiej listy. Wystarczy, że dostarczymy niezbędnych danych.


### tworzenie `ListFragment`

##### `file>new>fragment(list)`
lub prostsza wersja
##### `file>new>fragment(blank)
*WorkoutListFragment*
```kotlin
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.ListFragment

class WorkoutListFragment : ListFragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return super.onCreateView(inflater, container, savedInstanceState)
    }
}

```
- zwróć uwagę, że dziedziczenie jest po klasie `ListFragment()`!!!!!!
- Metoda `onCreateView` ta jest wywoływana w momencie tworzenia widoku używanego przez fragment.

### dodawanie danych do widoku
#### adapter
![[Pasted image 20240131102422.png]]

>[!tip] adapter
>Adapter działa jak most łączący widok oraz źródło danych. Adapter `ArrayAdapter` jest typem adaptera wyspecjalizowanego do operowania na tablicach.

> Chcemy dostarczyć do widoku listy we fragmencie WorkoutListFragment tablicę z nazwami treningów; dlatego, podobnie jak wcześniej, do powiązania danych z widokiem listy użyjemy adaptera typu ArrayAdapter

##### użycie adaptera
Aby użyć adaptera typu `ArrayAdapter`, należy
- go najpierw zainicjować, 
	- konstruktora adaptera przekazujemy trzy parametry:
		- obiekt `Context` (zazwyczaj jest to bieżąca aktywność), 
		- zasób układu określającego, jak wyświetlać poszczególne elementy tablicy, oraz 
		- samą tablicę.
	- np.
```kotlin
val listAdapter = ArrayAdapter(
    this,
    android.R.layout.simple_list_item_1,
    Drink.drinks
)
```
- a następnie dołączyć do widoku listy.

>[!danger] ważne
> `Fragment` nie jest klasą pochodną klasy `Context`. 
> Nie dysponuje zatem dostępem do informacji globalnych, a w kodzie fragmentu nie możemy użyć `this` w celu przekazania kontekstu do konstruktora adaptera `ArrayAdapter`.
> Oznacza to, że musimy pobrać ten kontekst w jakiś inny sposób.



`WorkoutListFragment.kt`
```kotlin
  
class WorkoutListFragment : ListFragment() {  
	override fun onCreateView(  
		inflater: LayoutInflater,  
		container: ViewGroup?,  
		savedInstanceState: Bundle?  
	): View? {  
  
	val names: Array<String> = arrayOf(*WorkoutRepository.workouts  
	.map { it.name }  
	.toTypedArray()  
	)  
  
	val adapter = ArrayAdapter(  
		inflater.context,  
		R.layout.simple_list_item_1,  
		names  
	)  
  
	listAdapter = adapter  
  
	return super.onCreateView(inflater, container, savedInstanceState)  
}  
}
```

```kotlin
arrayOf(*WorkoutRepository.workouts  
	.map { it.name }  
	.toTypedArray()  
	)
``` 
- `*` to jest operator *spread* (destrukturyzacja tablicy, więc do `arrayOf` trafią elementy tablicy a nie tablica)
- `map` wyciąga wartości `name`  listy z repozytorium,
- `map` zwraca listę, więc przekształcamy ją w typowaną tablicę `toTypedArray`

`listAdapter = adapter`
- Linia ta ustawia adapter dla listy wewnątrz fragmentu. W przypadku `ListFragment`, `listAdapter` to właściwość dostarczająca dostęp do adaptera listy, a `adapter` to obiekt klasy `ArrayAdapter`, który jest używany do wyświetlenia danych na liście.
- Warto zauważyć, że `listAdapter` jest dostępne dzięki dziedziczeniu z `ListFragment`, a Kotlin, w tym przypadku, nie wymaga jawnej deklaracji typu. W tym konkretnym fragmencie, Kotlin wie, że `listAdapter` to właściwość typu `ListAdapter?`, ponieważ jest to właściwość dostępna w klasie `ListFragment`.

### Wyświetlenie fragmentu `WorkoutListFragment` w układzie aktywności` MainActivity`
















