[[5. Widoki i grupy widoków]]
[[_ Rusz Głową Android. Programowanie aplikacji]]

### wszystkie układy i komponenty GUI są klasami dziedziczącymi po klasie `View`!!!

# Komponenty GUI
Są one pochodnymi klasy `View`.

> [!tip] Komponent GUI 
> jest typem widoku, obiektem zajmującym miejsce na ekranie.

`android.view.View` jest klasą podstawową dla wielu elementów interfejsu użytkownika w Androidzie. Jednak dziedziczenie jest następujące:

- `android.view.View` (Podstawowa klasa widoku)
    - `android.widget.TextView` (Podstawowa klasa dla wszystkich widoków tekstu)
        - `android.widget.EditText` (Klasa reprezentująca pole tekstowe)
    - `android.widget.Button` (Klasa reprezentująca przycisk)
    - `android.widget.Spinner` (Klasa reprezentująca rozwijaną listę)

>[!tip] UKŁAD
>Układ jest obiektem określanym jako ==grupa widoków== — to widok specjalnego typu, który może zawierać inne widoki.

`android.view.View` (Podstawowa klasa widoku)

- `android.view.ViewGroup` (Abstrakcyjna klasa kontenera dla widoków)
    - `android.widget.FrameLayout` (Kontener, który układa swoje dzieci w stosie)
    - `android.widget.LinearLayout` (Kontener, który układa swoje dzieci w jednym rzędzie)
    - `android.widget.RelativeLayout` (Kontener, który pozwala na określenie pozycji względem innych dzieci)
    - `android.widget.RelativeLayout` (Kontener, który pozwala na określenie pozycji względem innych dzieci)
    - `android.widget.AbsoluteLayout` (Kontener, który pozwala na określenie pozycji widoków przy użyciu wartości pikseli)
    - itd.

# obiekt `View`
to prostokątny obszar na ekranie, który zawiera pewne funkcjonalności:
- odczytywanie i ustawianie właściwości:
	- każdy widok to obiekt, więc możemy `set` i `get` jego właściwości
- wielkość i położeni:
	- określamy szerokość i wysokość widoku
	- określamy, czy widok ma wypełnienie, czy nie
- obsługa miejsca wprowadzania,
	- obsługa przenoszenia miejsca wprowadzania w zależności od czynności wykonywanych przez użytkownika
- obsługa zdarzeń i obiekty nasłuchujące
	- każdy widok może odpowiadać na zdarzenia
	- możemy tworzyć obiekty nasłuchujące, które reagują na to, co się dzieje z widokiem (np. reakcja na kliknięcie)

# Układ to hierarchia widoków
czyli układy mają wszystkie w/w funkcjonalności

```xml
<LinearLayout ...
	<Button ...

	<EditText ...
</Linear ...
```
to jest HERARCHICZBE DRZEWO WIDOKÓW:
- `ViewGroup`
	- `View`
	- `View`
Podczas tworzenia aplikacji kod `XML` układu jest za kulisami przekształcany na obiekt `ViewGroup`, który zawiera drzewo obiektów `View`:
- przycisk przekształcony na obiekt `Button`
- pole tekstowe na obiekt `EditText`

>[!fail] WAŻNE
>Za kulisami wszystkie widoki są bowiem przekształcane do postaci obiektów typu `View`

# Najpopularniejsze komponenty GUI:
## Widok tekstowy `TextView`
służy do wyświetlania fragmentów tekstu na ekranie:
```xml
<TextView 
	android:id=”@+id/text_view”
	android:layout_width=”wrap_content” 
	android:layout_height=”wrap_content” 
	android:text=”@string/text”
	android:textSize="16sp"
		  />
```

```kotlin
val textView: TextView = findViewById(R.id.text_view) as TextView
textView.text = "Jakiś inny tekst"

```

## Pole tekstowe `<EditText>`
pozwalają edytować wyświetlany w nich tekst
```xml
<EditText 
	android:id=”@+id/edit_text”
	android:layout_width=”wrap_content” 
	android:layout_height=”wrap_content” 
	android:hint=”@string/edit_text” />
```
Atrybut `android:inputType` w elemencie XML interfejsu użytkownika Android pozwala na określenie oczekiwanego typu danych, jakie użytkownik powinien wprowadzać do danego pola tekstowego.
Jeśli chcesz, aby użytkownik wprowadzał liczby, możesz użyć `android:inputType="number"`.

Przykłady innych wartości, jakie można użyć w atrybucie `android:inputType`, obejmują:

- `"text"`: Domyślny tryb tekstu.
- `"textPassword"`: Hasło tekstowe.
- `"textEmailAddress"`: Adres e-mail.
- `"phone"`: Numer telefonu.
- `"number"`: Liczba całkowita.
- `"numberDecimal"`: Liczba dziesiętna.
- `"date"`: Data.
- `"time"`: Czas.

Można również łączyć różne wartości, aby określić bardziej szczegółowy rodzaj danych, na przykład `android:inputType="textCapSentences|textAutoCorrect"`.

```kotlin
val editText = findViewById<EditText>(R.id.edit_text)
val text: String = editText.text.toString()

```

## Przycisk `<Button>`
```xml
<Button 
	android:id=”@+id/button”
	android:layout_width=”wrap_content” 
	android:layout_height=”wrap_content” 
	android:text=”@string/button_text” />
```
`onClick`
```xml
<Button 
	android:onClick=”onButtonClicked”
	...
```


```kotlin
fun onButtonClicked(View view){

}
```

## Przycisk przełącznik `<ToggleButton>`
dwa stany:
- wyłączony
- włączony (po kliknięciu)

>[!tip] hierarchia dziedziczenia dla `ToggleButton`:
>- `android.view.View`
  >  - `android.widget.TextView`
    >    - `android.widget.Button`
      >      - `android.widget.CompoundButton`
        >        - `android.widget.ToggleButton`


```xml
<ToggleButton 
	android:id=”@+id/toggle_button” 
	android:layout_width=”wrap_content” 
	android:layout_height=”wrap_content” 
	android:textOn=”@string/on” 
	android:textOff=”@string/off” />
```

`android:onClick=”onToggleButtonClicked"`
```kotlin
fun onToggleButtonClicked(view: View) {
    // Pobieramy stan przycisku przełącznika
    val on = (view as ToggleButton).isChecked

    if (on) {
        // Przycisk włączony
    } else {
        // Przycisk wyłączony
    }
}

```

