
>[!info] GRAF
>- zbiÃ³r obiektÃ³w , ktÃ³re pozostajÄ… ze sobÄ… czasami w pewnej relacji
>- obiekty to wierzechoÅ‚ki (*nodes*, *vertices*)
>- relacje to krawÄ™dzie (*edges*, *lines*)

opis grafÃ³w: to zbiÃ³r wierzchoÅ‚kÃ³w + zbiÃ³r krawÄ™dzi

![[graf_pomysÅ‚_na_wyjazd.excalidraw | 800]]

Jak ten ksztaÅ‚ przepisaÄ‡ na kod komputerowy?
- jak zakodowaÄ‡ dane? ==strukutry danych==
- jak przetwarzac dane? ==algorytmy==

---
# Graf nieskierowany
![[graf_nieskierowany_relacje_miÅ‚osne.excalidraw | 400]]

$V=\{Julia, Romeo, Laurenty, Parys\}$

$E= \{ \{Julia, Romeo \}, \{Julia, Laurenty\},$
$\{Julia, Parys \}, \{Laureny, Romeo \}, \{Parys, Romeo \} \}$

$$
ð¸ âŠ† {{ð‘¢, ð‘£}: ð‘¢, ð‘£ âˆˆ ð‘‰, ð‘¢ â‰  ð‘£}
$$


Graf bÄ™dzie teÅ¼ wtedy, gdyby te postaci nie znaÅ‚y siÄ™, wÃ³wczas zbiÃ³r $E$ byÅ‚by pusty.

>[[!info]] Graf, graf prosty lub graf nieskierowany $G$
> skÅ‚ada siÄ™ z dwÃ³ch zbiorÃ³w: 
> - $V$ oraz $E$, przy czym: 
> 	- *V* jest niepustym zbiorem, ktÃ³rego elementy nazywane sÄ… wierzchoÅ‚kami, a 
> 	- *E* jest rodzinÄ… dwuelementowych podzbiorÃ³w zbioru wierzchoÅ‚kÃ³w *V*, zwanych krawÄ™dziami: $ð¸ âŠ† {{ð‘¢, ð‘£}: ð‘¢, ð‘£ âˆˆ ð‘‰, ð‘¢ â‰  ð‘£}$
> 	- 

```python
V = ['Julia', 'Romeo', 'Parys', 'Laurenty']
E = [
Â  Â  ['Julia', 'Romeo'], ['Julia', 'Parys'], ['Julia', 'Laurenty'],
Â  Â  ['Romeo', 'Parys'], ['Romeo', 'Laurenty'],
]

# Kto zna JuliÄ™?
def who_knows_person(person, E):
Â  Â  friends=[]
Â  Â  for first_person, second_person in E:
Â  Â  Â  Â  if first_person == person:
Â  Â  Â  Â  Â  Â  friends.append(second_person)
Â  Â  Â  Â  elif second_person == person:
Â  Â  Â  Â  Â  Â  friends.append(first_person)
Â  Â  return friends

print(who_knows_person('Laurenty', E))
```



# Grafy skierowane

![[graf_skierowany.42.excalidraw | 600]]


$$
V=\{1,2,3,4,5\}
$$


$$
E=\{(1,2),(2,3),(3,4), (1,5), (5,4) \}
$$

```python
# show nodes reachable from node start
V=[1,2,3,4,5]
E=[(1,2),(2,3),(3,4), (1,5), (5,4) ]
start = 1
for x, y in E:
    if x == start:
        print(y)
        
print("---"*3)
```








