
>[!info] GRAF
>- zbiÃ³r obiektÃ³w , ktÃ³re pozostajÄ… ze sobÄ… czasami w pewnej relacji
>- obiekty to wierzechoÅ‚ki (*nodes*, *vertices*)
>- relacje to krawÄ™dzie (*edges*, *lines*)

opis grafÃ³w: to zbiÃ³r wierzchoÅ‚kÃ³w + zbiÃ³r krawÄ™dzi

![[graf_pomysÅ‚_na_wyjazd.excalidraw | 800]]

Jak ten ksztaÅ‚ przepisaÄ‡ na kod komputerowy?
- jak zakodowaÄ‡ dane? ==strukutry danych==
- jak przetwarzac dane? ==algorytmy==

---
# Graf nieskierowany
![[graf_nieskierowany_relacje_miÅ‚osne.excalidraw | 400]]

$V=\{Julia, Romeo, Laurenty, Parys\}$

$E= \{ \{Julia, Romeo \}, \{Julia, Laurenty\},$
$\{Julia, Parys \}, \{Laureny, Romeo \}, \{Parys, Romeo \} \}$

$$
ğ¸ âŠ† {{ğ‘¢, ğ‘£}: ğ‘¢, ğ‘£ âˆˆ ğ‘‰, ğ‘¢ â‰  ğ‘£}
$$


Graf bÄ™dzie teÅ¼ wtedy, gdyby te postaci nie znaÅ‚y siÄ™, wÃ³wczas zbiÃ³r $E$ byÅ‚by pusty.

>[[!info]] Graf, graf prosty lub graf nieskierowany $G$
> skÅ‚ada siÄ™ z dwÃ³ch zbiorÃ³w: 
> - $V$ oraz $E$, przy czym: 
> 	- *V* jest niepustym zbiorem, ktÃ³rego elementy nazywane sÄ… wierzchoÅ‚kami, a 
> 	- *E* jest rodzinÄ… dwuelementowych podzbiorÃ³w zbioru wierzchoÅ‚kÃ³w *V*, zwanych krawÄ™dziami: $ğ¸ âŠ† \{\{ğ‘¢, ğ‘£\}: ğ‘¢, ğ‘£ âˆˆ ğ‘‰, ğ‘¢ â‰  ğ‘£\}$
> 	- 

```python
V = ['Julia', 'Romeo', 'Parys', 'Laurenty']
E = [
Â  Â  ['Julia', 'Romeo'], ['Julia', 'Parys'], ['Julia', 'Laurenty'],
Â  Â  ['Romeo', 'Parys'], ['Romeo', 'Laurenty'],
]

# Kto zna JuliÄ™?
def who_knows_person(person, E):
Â  Â  friends=[]
Â  Â  for first_person, second_person in E:
Â  Â  Â  Â  if first_person == person:
Â  Â  Â  Â  Â  Â  friends.append(second_person)
Â  Â  Â  Â  elif second_person == person:
Â  Â  Â  Â  Â  Â  friends.append(first_person)
Â  Â  return friends

print(who_knows_person('Laurenty', E))
```



# Grafy skierowane

>[[!info]] Digraf ( graf skierowany)
>SkÅ‚ada siÄ™ z dwÃ³ch zbiorÃ³w:
>- niepusty zbiÃ³r wierzchoÅ‚kÃ³w $V$,
>- rodziny par $E$ uporzÄ…dkowanych elementÃ³w zbioru $V$, zwanych krawÄ™dziami lub Å‚ikami grafu skierowanego


![[graf_skierowany.42.excalidraw | 600]]


$$
V=\{1,2,3,4,5\}
$$


$$
E=\{(1,2),(2,3),(3,4), (1,5), (5,4) \}
$$
$$
ğ¸ âŠ† \{(ğ‘¢, ğ‘£): ğ‘¢, ğ‘£ âˆˆ ğ‘‰, ğ‘¢ â‰  ğ‘£\}$
$$


```python
# show nodes reachable from node start
V=[1,2,3,4,5]
E=[(1,2),(2,3),(3,4), (1,5), (5,4) ]
start = 1
for x, y in E:
    if x == start:
        print(y)
        
print("---"*3)
print("---")
print([y for (x,y) in E if x == start ])
```


```python
V = ['Dworzec PKP', "Rozkopy przy Victorze", "Aura", "Stare Miasto", "MacDonalds", "Galeria WarmiÅ„ska"]

E = [('Dworzec PKP' , "Rozkopy przy Victorze"),
Â  Â  Â ('Dworzec PKP' , "Stare Miasto"),
Â  Â  Â ("Stare Miasto", "Galeria WarmiÅ„ska" ),
Â  Â  Â ("Rozkopy przy Victorze", "Aura"),
Â  Â  Â ("Aura", "MacDonalds"),
Â  Â  Â ("MacDonalds", "Galeria WarmiÅ„ska"),
Â  Â  ]

# jaki nastÄ™pny przystanek, nastÄ™pny przystanek, od przystanku start
start = 'Dworzec PKP'
for f,s in E:
Â  Â  if f == start:
Â  Â  Â  Â  print(s)
print([s for (f,s) in E if f == start])

# Aby dojechaÄ‡ do przystanku koniec
end="Aura"
for f,s in E:
Â  Â  if s == end:
Â  Â  Â  Â  print(f)
print([f for (f,s) in E if s==end])
```


# Zapis grafÃ³w w postaci macierzy

Macierz bÄ™dzie miaÅ‚a tyle elementÃ³w i kolumn ile wierszy w zbiorze $V$

> Macierz grafu nieskierowanego jest symetryczna
> Macierz grafu skierowanego jest niesymetryczna.


## graf nieskierowany
`V = ['Julia', 'Romeo', 'Parys', 'Laurenty']`
Pracujemy na indeksach:
- 0 - Julia
- 1 - Romeo
- 2 - Parys
- 3 - Laurenty

x  | 0   | 1   | 2    | 3
-- | --  | --  | --   | --
0  |  0  |  1  |  1   | 1
1  |  1  | 0   |  1   | 1
2  |  1  | 1   |  0   | 0
3  |  1  | 1   |  0   | 0

```python
V = ['Julia', 'Romeo', 'Parys', 'Laurenty']
E = [
Â  Â  Â ['Julia', 'Romeo'], ['Julia', 'Parys'], ['Julia', 'Laurenty'],
Â  Â  Â ['Romeo', 'Parys'], ['Romeo', 'Laurenty'],
]

# Julia - 0, Romeo - 1, Parys - 2, Laurenty -3
matrix = [
Â  Â  [0,1,1,1],
Â  Â  [1,0,1,1],
Â  Â  [1,1,0,0],
Â  Â  [1,1,0,0]
]

def who_knows_person(person, V, matrix):
Â  Â  friends = []
Â  Â  idx = V.index(person)

Â  Â  for i in range(len(V)):
Â  Â  Â  Â  if matrix[idx][i] == 1:
Â  Â  Â  Â  Â  Â  friends.append(V[i])
Â  Â  return friends

print(who_knows_person("Romeo", V, matrix))
```




## graf skierowany

V = [1,2,3,4] # indeksy w macierzy 1->index 0, 2->index 1 ...
E = [ (1,2), (2,4), (1,3), (3,4)]


x  | 0   | 1   | 2    | 3
-- | --  | --  | --   | --
0  |  0  |  1  |  1   | 0
1  |  0  | 0   |  0   | 1
2  |  0  | 0   |  0   | 1
3  |  0  | 0   |  0   | 0



