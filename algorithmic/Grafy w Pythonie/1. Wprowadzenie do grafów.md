
>[!info] GRAF
>- zbiÃ³r obiektÃ³w , ktÃ³re pozostajÄ… ze sobÄ… czasami w pewnej relacji
>- obiekty to wierzechoÅ‚ki (*nodes*, *vertices*)
>- relacje to krawÄ™dzie (*edges*, *lines*)

opis grafÃ³w: to zbiÃ³r wierzchoÅ‚kÃ³w + zbiÃ³r krawÄ™dzi

![[graf_pomysÅ‚_na_wyjazd.excalidraw | 800]]

Jak ten ksztaÅ‚ przepisaÄ‡ na kod komputerowy?
- jak zakodowaÄ‡ dane? ==strukutry danych==
- jak przetwarzac dane? ==algorytmy==

---
# Graf nieskierowany
![[graf_nieskierowany_relacje_miÅ‚osne.excalidraw | 400]]

$V=\{Julia, Romeo, Laurenty, Parys\}$

$E= \{ \{Julia, Romeo \}, \{Julia, Laurenty\},$
$\{Julia, Parys \}, \{Laureny, Romeo \}, \{Parys, Romeo \} \}$

$$
ð¸ âŠ† {{ð‘¢, ð‘£}: ð‘¢, ð‘£ âˆˆ ð‘‰, ð‘¢ â‰  ð‘£}
$$


Graf bÄ™dzie teÅ¼ wtedy, gdyby te postaci nie znaÅ‚y siÄ™, wÃ³wczas zbiÃ³r $E$ byÅ‚by pusty.

>[!info] Graf, graf prosty lub graf nieskierowany $G$
> skÅ‚ada siÄ™ z dwÃ³ch zbiorÃ³w: 
> - $V$ oraz $E$, przy czym: 
> 	- *V* jest niepustym zbiorem, ktÃ³rego elementy nazywane sÄ… wierzchoÅ‚kami, a 
> 	- *E* jest rodzinÄ… dwuelementowych podzbiorÃ³w zbioru wierzchoÅ‚kÃ³w *V*, zwanych krawÄ™dziami: $ð¸ âŠ† \{\{ð‘¢, ð‘£\}: ð‘¢, ð‘£ âˆˆ ð‘‰, ð‘¢ â‰  ð‘£\}$
> 	- 

```python
V = ['Julia', 'Romeo', 'Parys', 'Laurenty']
E = [
Â  Â  ['Julia', 'Romeo'], ['Julia', 'Parys'], ['Julia', 'Laurenty'],
Â  Â  ['Romeo', 'Parys'], ['Romeo', 'Laurenty'],
]

# Kto zna JuliÄ™?
def who_knows_person(person, E):
Â  Â  friends=[]
Â  Â  for first_person, second_person in E:
Â  Â  Â  Â  if first_person == person:
Â  Â  Â  Â  Â  Â  friends.append(second_person)
Â  Â  Â  Â  elif second_person == person:
Â  Â  Â  Â  Â  Â  friends.append(first_person)
Â  Â  return friends

print(who_knows_person('Laurenty', E))
```



# Grafy skierowane

>[!info] Digraf ( graf skierowany)
>SkÅ‚ada siÄ™ z dwÃ³ch zbiorÃ³w:
>- niepusty zbiÃ³r wierzchoÅ‚kÃ³w $V$,
>- rodziny par $E$ uporzÄ…dkowanych elementÃ³w zbioru $V$, zwanych krawÄ™dziami lub Å‚ikami grafu skierowanego


![[graf_skierowany.42.excalidraw | 600]]


$$
V=\{1,2,3,4,5\}
$$


$$
E=\{(1,2),(2,3),(3,4), (1,5), (5,4) \}
$$
$$
ð¸ âŠ† \{(ð‘¢, ð‘£): ð‘¢, ð‘£ âˆˆ ð‘‰, ð‘¢ â‰  ð‘£\}$
$$


```python
# show nodes reachable from node start
V=[1,2,3,4,5]
E=[(1,2),(2,3),(3,4), (1,5), (5,4) ]
start = 1
for x, y in E:
    if x == start:
        print(y)
        
print("---"*3)

print([y for (x,y) in E if x == start ])
```


```python
V = ['Dworzec PKP', "Rozkopy przy Victorze", "Aura", "Stare Miasto", "MacDonalds", "Galeria WarmiÅ„ska"]

E = [('Dworzec PKP' , "Rozkopy przy Victorze"),
Â  Â  Â ('Dworzec PKP' , "Stare Miasto"),
Â  Â  Â ("Stare Miasto", "Galeria WarmiÅ„ska" ),
Â  Â  Â ("Rozkopy przy Victorze", "Aura"),
Â  Â  Â ("Aura", "MacDonalds"),
Â  Â  Â ("MacDonalds", "Galeria WarmiÅ„ska"),
Â  Â  ]

# jaki nastÄ™pny przystanek,  od przystanku start
start = 'Dworzec PKP'
for f,s in E:
Â  Â  if f == start:
Â  Â  Â  Â  print(s)
print([s for (f,s) in E if f == start])

# Aby dojechaÄ‡ do przystanku koniec
end="Aura"
for f,s in E:
Â  Â  if s == end:
Â  Â  Â  Â  print(f)
print([f for (f,s) in E if s==end])
```


# Zapis grafÃ³w w postaci macierzy

Macierz bÄ™dzie miaÅ‚a tyle elementÃ³w i kolumn, ile wierszy w zbiorze $V$

> Macierz grafu nieskierowanego jest symetryczna
> Macierz grafu skierowanego jest niesymetryczna.


## graf nieskierowany
`V = ['Julia', 'Romeo', 'Parys', 'Laurenty']`
Pracujemy na indeksach:
- 0 - Julia
- 1 - Romeo
- 2 - Parys
- 3 - Laurenty

x  | 0   | 1   | 2    | 3
-- | --  | --  | --   | --
0  |  0  |  1  |  1   | 1
1  |  1  | 0   |  1   | 1
2  |  1  | 1   |  0   | 0
3  |  1  | 1   |  0   | 0

```python
V = ['Julia', 'Romeo', 'Parys', 'Laurenty']
E = [
Â  Â  Â ['Julia', 'Romeo'], ['Julia', 'Parys'], ['Julia', 'Laurenty'],
Â  Â  Â ['Romeo', 'Parys'], ['Romeo', 'Laurenty'],
]

# Julia - 0, Romeo - 1, Parys - 2, Laurenty -3
matrix = [
Â  Â  [0,1,1,1],
Â  Â  [1,0,1,1],
Â  Â  [1,1,0,0],
Â  Â  [1,1,0,0]
]

def who_knows_person(person, V, matrix):
Â   Â  friends = []
Â  Â  idx = V.index(person)

Â  Â  for i in range(len(V)):
Â  Â  Â  Â  if matrix[idx][i] == 1:
Â  Â  Â  Â  Â  Â  friends.append(V[i])
Â  Â  return friends

print(who_knows_person("Romeo", V, matrix))
```

## graf skierowany
V = [1,2,3,4] # indeksy w macierzy 1->index 0, 2->index 1 ...
E = [ (1,2), (2,4), (1,3), (3,4)]

x  | 0   | 1   | 2    | 3
-- | --  | --  | --   | --
0  |  0  |  1  |  1   | 0
1  |  0  | 0   |  0   | 1
2  |  0  | 0   |  0   | 1
3  |  0  | 0   |  0   | 0

```python
V = [1,2,3,4] # indeksy w macierzy 1->index 0, 2->index 1 ...
E = [
Â  Â  (1,2),
Â  Â  (2,4),
Â  Â  (1,3),
Â  Â  (3,4)
]

matrix = [
Â  Â  [0,1,1,0],
Â  Â  [0,0,0,1],
Â  Â  [0,0,0,1],
Â  Â  [0,0,0,0],
]

start = 2
idx = V.index(start)
for i in range(len(V)):
Â  Â  if matrix[idx][i] == 1:
Â  Â  Â  Â  print(V[i])
print('-'*5)
print([V[i] for i in range(len(V)) if matrix[V.index(start)][i] == 1 ])
```


## Zadanie
dane sÄ… dwa zbiory:
`V = ["a", "b", "c", "d", "f"]`
`E=[ (0,2), (1,2), (2,3), (2,4)]
`a->c`, `b->c`, `c->d`, `c->f`

stwÃ³rz funkcjÄ™, ktÃ³ra przyjmuje V, E a zwraca macierz opisujÄ…cÄ… graf
```python
V = ["a", "b", "c", "d", "f"]
E=[ (0,2), (1,2), (2,3), (2,4)]

def create_matrix(V, E):
Â  Â  matrix=[]
Â  Â  for i in range(len(V)):
Â  Â  Â  Â  row=[0 for _ in range(len(V))]
Â  Â  Â  Â  for first, second in E:
Â  Â  Â  Â  Â  Â  if i == first:
Â  Â  Â  Â  Â  Â  Â  Â  row[second] = 1
Â  Â  Â  Â  matrix.append(row)
Â  Â  return matrix

def create_matrix2(V,E):
Â  Â  matrix = []
Â  Â  for val1 in range(len(V)):
Â  Â  Â  Â  matrix.append([1 if (val1, val2) in E else 0 for val2 in range(len(V))])
  
Â  Â  return matrix

m = create_matrix2(V, E)
for i in m:
Â  Â  print(i)
```


# Lista sÄ…siadÃ³w (adjacent list)

![[graf_prezesem.excalidraw | 600]] 

`V={ZP, PE, ZE, ZPrez, RW }`
```python
E={
	ZP:[PE, RW],
	RW:[ZP, ZPrez],
	PE:[ZE],
	ZP:[]	
}

```

```python
def add_node(V, node):
Â  Â  if node in V.keys():
Â  Â  Â  Â  return
Â  Â  else:
Â  Â  Â  Â  V[node] = []

def add_edge(V, source, dest):
Â  Â  if not source in V.keys() or not dest in V.keys():
Â  Â  Â  Â  return
Â  Â  else:
Â  Â  Â  Â  if not dest in V[source]:
Â  Â  Â  Â  Â  Â  V[source].append(dest)
V={}
add_node(V, "ZP" )
add_node(V, "PE" )
add_node(V, "ZE" )
add_node(V, "Zprez" )
add_node(V, "RW" )
add_edge(V, 'RW', 'Zprez')
add_edge(V, 'RW', 'ZP')
add_edge(V, 'ZP', 'PE')
add_edge(V, 'ZP', 'RW')
add_edge(V, 'PE', 'ZE')
print(V)
```


# grafy waÅ¼one (grafy skierowane z wagami)

>[!info] graf waÅ¼ony
>To struktura:
>	- ==sÅ‚owniki==, ktÃ³rego **kluczami** sÄ… nazwy wierzchoÅ‚kÃ³w
>	- **wartoÅ›ciami** sÄ… teÅ¼ sÅ‚owniki:
>		- ktÃ³rych **kluczami** sÄ… wierzchoÅ‚ki, do ktÃ³rych istnieje bezpoÅ›rednie poÅ‚Ä…czenie
>		- a **wartoÅ›ciami** sÄ… przypisane wagi/koszt, zwiÄ…zane z pokonaniem danej krawÄ™dzi
 

![[graf_waÅ¼ony.excalidraw | 600]]

#### graf skierowany niewaÅ¼ony
V = {Smartphone, Web Browser, MP3, KsiÄ…Å¼ka}
{ 
	Smartphone: \[Web Browser, Book\] ,
	Web Browser: \[Book, MP3\],
	MP3: \[Book\]
	Book:[]
}

#### graf waÅ¼ony
{ 
	Smartphone: { Web Browser: 30, Book: 22 } ,
	Web Browser: {Book: 32, MP3: 25},
	MP3: {Book: 44},
	Book:[]
}

```python
V={}
def add_node(V, node):
Â  Â  if node in V.keys():
Â  Â  Â  Â  return
Â  Â  else:
Â  Â  Â  Â  V[node] = {}

def add_edge(V, source, dest, weight):
Â  Â  if not source in V.keys() or not dest in V.keys():
Â  Â  Â  Â  return
Â  Â  else:
Â  Â  Â  Â  if not dest in V[source].keys():
Â  Â  Â  Â  Â  Â  V[source][dest] Â = weight

V={}
add_node(V, "Smartphone" )
add_node(V, "Web Browser" )
add_node(V, "Book" )
add_node(V, "MP3" )

add_edge(V, 'Smartphone', 'Web Browser', 30)
add_edge(V, 'Smartphone', 'Book', 22)
add_edge(V, 'Web Browser', 'Book', 32)
add_edge(V, 'Web Browser', 'MP3', 25)
add_edge(V, 'MP3', 'Book', 44)

print(V)
print(f'Koszt czasu Web Browser->Book {V["Web Browser"]["Book"]}')
```



# StopieÅ„ Grafu
  
  >[!info] stopieÅ„ wierzchoÅ‚ka (*node degree*)
  > to liczba krawÄ™dzi powiÄ…zanych z danym wierzchoÅ‚kiem (*node*)
  > $Degree(nodeName)$
  
w grafach skierowanych:
- ==in-degree== liczba krawÄ™dzi wchodzÄ…cych do wierzchoÅ‚ka
- ==out-degree== liczba krawÄ™dzi wychodzÄ…cych 

>[!info] stopieÅ„ grafu
>maksymalny stopieÅ„ wierdzchoÅ‚kÃ³w tego grafu
>$Degree(V)$
   
```python
# Graph - Romeo, Julia, Paris, Laurenty
V={
Â  Â  "J":["R","P","L"],
Â  Â  "R":["J","P", "L"],
Â  Â  "L":["J","R"],
Â  Â  "P":["J","R"],
}

def graph_degree(V):
Â  Â  return max([node_degree(V, n) for n in V.keys() Â ])

def node_degree(V, node):
Â  Â  if node in V.keys():
Â  Â  Â  Â  return len(V[node])
Â  Â  else:
Â  Â  Â  Â  return -1

for n in V.keys():
Â  Â  print(f'Degree of {n}: {node_degree(V, n)}')

print(f'graph degree {graph_degree(V)}')
```

# Firmowy krÃ³l mejli
https://snap.stanford.edu/data/email-Eu-core.html ()







