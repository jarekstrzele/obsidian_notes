
>[!info] GRAF
>- zbi√≥r obiekt√≥w , kt√≥re pozostajƒÖ ze sobƒÖ czasami w pewnej relacji
>- obiekty to wierzecho≈Çki (*nodes*, *vertices*)
>- relacje to krawƒôdzie (*edges*, *lines*)

opis graf√≥w: to zbi√≥r wierzcho≈Çk√≥w + zbi√≥r krawƒôdzi

![[graf_pomys≈Ç_na_wyjazd.excalidraw | 800]]

Jak ten kszta≈Ç przepisaƒá na kod komputerowy?
- jak zakodowaƒá dane? ==strukutry danych==
- jak przetwarzac dane? ==algorytmy==

---
# Graf nieskierowany
![[graf_nieskierowany_relacje_mi≈Çosne.excalidraw | 400]]

$V=\{Julia, Romeo, Laurenty, Parys\}$

$E= \{ \{Julia, Romeo \}, \{Julia, Laurenty\},$
$\{Julia, Parys \}, \{Laureny, Romeo \}, \{Parys, Romeo \} \}$

$$
ùê∏ ‚äÜ {{ùë¢, ùë£}: ùë¢, ùë£ ‚àà ùëâ, ùë¢ ‚â† ùë£}
$$


Graf bƒôdzie te≈º wtedy, gdyby te postaci nie zna≈Çy siƒô, w√≥wczas zbi√≥r $E$ by≈Çby pusty.

>[[!info]] Graf, graf prosty lub graf nieskierowany $G$
> sk≈Çada siƒô z dw√≥ch zbior√≥w: 
> - $V$ oraz $E$, przy czym: 
> 	- *V* jest niepustym zbiorem, kt√≥rego elementy nazywane sƒÖ wierzcho≈Çkami, a 
> 	- *E* jest rodzinƒÖ dwuelementowych podzbior√≥w zbioru wierzcho≈Çk√≥w *V*, zwanych krawƒôdziami: $ùê∏ ‚äÜ \{\{ùë¢, ùë£\}: ùë¢, ùë£ ‚àà ùëâ, ùë¢ ‚â† ùë£\}$
> 	- 

```python
V = ['Julia', 'Romeo', 'Parys', 'Laurenty']
E = [
¬† ¬† ['Julia', 'Romeo'], ['Julia', 'Parys'], ['Julia', 'Laurenty'],
¬† ¬† ['Romeo', 'Parys'], ['Romeo', 'Laurenty'],
]

# Kto zna Juliƒô?
def who_knows_person(person, E):
¬† ¬† friends=[]
¬† ¬† for first_person, second_person in E:
¬† ¬† ¬† ¬† if first_person == person:
¬† ¬† ¬† ¬† ¬† ¬† friends.append(second_person)
¬† ¬† ¬† ¬† elif second_person == person:
¬† ¬† ¬† ¬† ¬† ¬† friends.append(first_person)
¬† ¬† return friends

print(who_knows_person('Laurenty', E))
```



# Grafy skierowane

>[!info] Digraf ( graf skierowany)
>Sk≈Çada siƒô z dw√≥ch zbior√≥w:
>- niepusty zbi√≥r wierzcho≈Çk√≥w $V$,
>- rodziny par $E$ uporzƒÖdkowanych element√≥w zbioru $V$, zwanych krawƒôdziami lub ≈Çikami grafu skierowanego


![[graf_skierowany.42.excalidraw | 600]]


$$
V=\{1,2,3,4,5\}
$$


$$
E=\{(1,2),(2,3),(3,4), (1,5), (5,4) \}
$$
$$
ùê∏ ‚äÜ \{(ùë¢, ùë£): ùë¢, ùë£ ‚àà ùëâ, ùë¢ ‚â† ùë£\}$
$$


```python
# show nodes reachable from node start
V=[1,2,3,4,5]
E=[(1,2),(2,3),(3,4), (1,5), (5,4) ]
start = 1
for x, y in E:
    if x == start:
        print(y)
        
print("---"*3)

print([y for (x,y) in E if x == start ])
```


```python
V = ['Dworzec PKP', "Rozkopy przy Victorze", "Aura", "Stare Miasto", "MacDonalds", "Galeria Warmi≈Ñska"]

E = [('Dworzec PKP' , "Rozkopy przy Victorze"),
¬† ¬† ¬†('Dworzec PKP' , "Stare Miasto"),
¬† ¬† ¬†("Stare Miasto", "Galeria Warmi≈Ñska" ),
¬† ¬† ¬†("Rozkopy przy Victorze", "Aura"),
¬† ¬† ¬†("Aura", "MacDonalds"),
¬† ¬† ¬†("MacDonalds", "Galeria Warmi≈Ñska"),
¬† ¬† ]

# jaki nastƒôpny przystanek, nastƒôpny przystanek, od przystanku start
start = 'Dworzec PKP'
for f,s in E:
¬† ¬† if f == start:
¬† ¬† ¬† ¬† print(s)
print([s for (f,s) in E if f == start])

# Aby dojechaƒá do przystanku koniec
end="Aura"
for f,s in E:
¬† ¬† if s == end:
¬† ¬† ¬† ¬† print(f)
print([f for (f,s) in E if s==end])
```


# Zapis graf√≥w w postaci macierzy

Macierz bƒôdzie mia≈Ça tyle element√≥w i kolumn, ile wierszy w zbiorze $V$

> Macierz grafu nieskierowanego jest symetryczna
> Macierz grafu skierowanego jest niesymetryczna.


## graf nieskierowany
`V = ['Julia', 'Romeo', 'Parys', 'Laurenty']`
Pracujemy na indeksach:
- 0 - Julia
- 1 - Romeo
- 2 - Parys
- 3 - Laurenty

x  | 0   | 1   | 2    | 3
-- | --  | --  | --   | --
0  |  0  |  1  |  1   | 1
1  |  1  | 0   |  1   | 1
2  |  1  | 1   |  0   | 0
3  |  1  | 1   |  0   | 0

```python
V = ['Julia', 'Romeo', 'Parys', 'Laurenty']
E = [
¬† ¬† ¬†['Julia', 'Romeo'], ['Julia', 'Parys'], ['Julia', 'Laurenty'],
¬† ¬† ¬†['Romeo', 'Parys'], ['Romeo', 'Laurenty'],
]

# Julia - 0, Romeo - 1, Parys - 2, Laurenty -3
matrix = [
¬† ¬† [0,1,1,1],
¬† ¬† [1,0,1,1],
¬† ¬† [1,1,0,0],
¬† ¬† [1,1,0,0]
]

def who_knows_person(person, V, matrix):
¬† ¬† friends = []
¬† ¬† idx = V.index(person)

¬† ¬† for i in range(len(V)):
¬† ¬† ¬† ¬† if matrix[idx][i] == 1:
¬† ¬† ¬† ¬† ¬† ¬† friends.append(V[i])
¬† ¬† return friends

print(who_knows_person("Romeo", V, matrix))
```

## graf skierowany
V = [1,2,3,4] # indeksy w macierzy 1->index 0, 2->index 1 ...
E = [ (1,2), (2,4), (1,3), (3,4)]

x  | 0   | 1   | 2    | 3
-- | --  | --  | --   | --
0  |  0  |  1  |  1   | 0
1  |  0  | 0   |  0   | 1
2  |  0  | 0   |  0   | 1
3  |  0  | 0   |  0   | 0

```python
V = [1,2,3,4] # indeksy w macierzy 1->index 0, 2->index 1 ...
E = [
¬† ¬† (1,2),
¬† ¬† (2,4),
¬† ¬† (1,3),
¬† ¬† (3,4)
]

matrix = [
¬† ¬† [0,1,1,0],
¬† ¬† [0,0,0,1],
¬† ¬† [0,0,0,1],
¬† ¬† [0,0,0,0],
]

start = 2
idx = V.index(start)
for i in range(len(V)):
¬† ¬† if matrix[idx][i] == 1:
¬† ¬† ¬† ¬† print(V[i])
print('-'*5)
print([V[i] for i in range(len(V)) if matrix[V.index(start)][i] == 1 ])
```


## Zadanie
dane sƒÖ dwa zbiory:
`V = ["a", "b", "c", "d", "f"]`
`E=[ (0,2), (1,2), (2,3), (2,4)]
`a->c`, `b->c`, `c->d`, `c->f`

stw√≥rz funkcjƒô, kt√≥ra przyjmuje V, E a zwraca macierz opisujƒÖcƒÖ graf
```python
V = ["a", "b", "c", "d", "f"]
E=[ (0,2), (1,2), (2,3), (2,4)]

def create_matrix(V, E):
¬† ¬† matrix=[]
¬† ¬† for i in range(len(V)):
¬† ¬† ¬† ¬† row=[0 for _ in range(len(V))]
¬† ¬† ¬† ¬† for first, second in E:
¬† ¬† ¬† ¬† ¬† ¬† if i == first:
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† row[second] = 1
¬† ¬† ¬† ¬† matrix.append(row)
¬† ¬† return matrix

def create_matrix2(V,E):
¬† ¬† matrix = []
¬† ¬† for val1 in range(len(V)):
¬† ¬† ¬† ¬† matrix.append([1 if (val1, val2) in E else 0 for val2 in range(len(V))])
  
¬† ¬† return matrix

m = create_matrix2(V, E)
for i in m:
¬† ¬† print(i)
```


# Lista sƒÖsiad√≥w (adjacent list)

![[graf_prezesem.excalidraw | 600]] 

`V={ZP, PE, ZE, ZPrez, RW }`
```python
E={
	ZP:[PE, RW],
	RW:[ZP, ZPrez],
	PE:[ZE],
	ZP:[]	
}

```

```python
def add_node(V, node):
¬† ¬† if node in V.keys():
¬† ¬† ¬† ¬† return
¬† ¬† else:
¬† ¬† ¬† ¬† V[node] = []

def add_edge(V, source, dest):
¬† ¬† if not source in V.keys() or not dest in V.keys():
¬† ¬† ¬† ¬† return
¬† ¬† else:
¬† ¬† ¬† ¬† if not dest in V[source]:
¬† ¬† ¬† ¬† ¬† ¬† V[source].append(dest)
V={}
add_node(V, "ZP" )
add_node(V, "PE" )
add_node(V, "ZE" )
add_node(V, "Zprez" )
add_node(V, "RW" )
add_edge(V, 'RW', 'Zprez')
add_edge(V, 'RW', 'ZP')
add_edge(V, 'ZP', 'PE')
add_edge(V, 'ZP', 'RW')
add_edge(V, 'PE', 'ZE')
print(V)
```


# grafy wa≈ºone (grafy skierowane z wagami)

>[!info] graf wa≈ºony
>To struktura:
>	- ==s≈Çowniki==, kt√≥rego **kluczami** sƒÖ nazwy wierzcho≈Çk√≥w
>	- **warto≈õciami** sƒÖ te≈º s≈Çowniki:
>		- kt√≥rych **kluczami** sƒÖ wierzcho≈Çki, do kt√≥rych istnieje bezpo≈õrednie po≈ÇƒÖczenie
>		- a **warto≈õciami** sƒÖ przypisane wagi/koszt, zwiƒÖzane z pokonaniem danej krawƒôdzi
 

![[graf_wa≈ºony.excalidraw | 600]]

#### graf skierowany niewa≈ºony
V = {Smartphone, Web Browser, MP3, KsiƒÖ≈ºka}
{ 
	Smartphone: \[Web Browser, Book\] ,
	Web Browser: \[Book, MP3\],
	MP3: \[Book\]
	Book:[]
}

#### graf wa≈ºony
{ 
	Smartphone: { Web Browser: 30, Book: 22 } ,
	Web Browser: {Book: 32, MP3: 25},
	MP3: {Book: 44},
	Book:[]
}

```python
V={}
def add_node(V, node):
¬† ¬† if node in V.keys():
¬† ¬† ¬† ¬† return
¬† ¬† else:
¬† ¬† ¬† ¬† V[node] = {}

def add_edge(V, source, dest, weight):
¬† ¬† if not source in V.keys() or not dest in V.keys():
¬† ¬† ¬† ¬† return
¬† ¬† else:
¬† ¬† ¬† ¬† if not dest in V[source].keys():
¬† ¬† ¬† ¬† ¬† ¬† V[source][dest] ¬†= weight

V={}
add_node(V, "Smartphone" )
add_node(V, "Web Browser" )
add_node(V, "Book" )
add_node(V, "MP3" )

add_edge(V, 'Smartphone', 'Web Browser', 30)
add_edge(V, 'Smartphone', 'Book', 22)
add_edge(V, 'Web Browser', 'Book', 32)
add_edge(V, 'Web Browser', 'MP3', 25)
add_edge(V, 'MP3', 'Book', 44)

print(V)
print(f'Koszt czasu Web Browser->Book {V["Web Browser"]["Book"]}')
```



# Stopie≈Ñ Grafu
  
  >[!info] stopie≈Ñ wierzcho≈Çka (*node degree*)
  > to liczba krawƒôdzi powiƒÖzanych z danym wierzcho≈Çkiem (*node*)
  > $Degree(nodeName)$
  
w grafach skierowanych:
- ==in-degree== liczba krawƒôdzi wchodzƒÖcych do wierzcho≈Çka
- ==out-degree== liczba krawƒôdzi wychodzƒÖcych 

>[!info] stopie≈Ñ grafu
>maksymalny stopie≈Ñ wierdzcho≈Çk√≥w tego grafu
>$Degree(V)$
   
  
# Firmowy kr√≥l mejli
https://snap.stanford.edu/data/email-Eu-core.html ()







