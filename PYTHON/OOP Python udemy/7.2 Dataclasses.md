#python/dataclass 
[[7 DataClasses]]

>[!info] dataclass
>It is just like a regular class but fine tuned for storing 	state rather than behavior

```python
from dataclasses import dataclass
@dataclass
class Bike:
  brand: str
  price: int
  name: str

my_super_bike = Bike("Składak", 9098, "Twoje Mrzenie")
print(f"{my_super_bike.brand =}, {my_super_bike.price =}, {my_super_bike.name =}")


```


```python
from os import truncate
from dataclasses import dataclass
### with normal class: `from functools import total_ordering
### and decorate class with @total_ordering, then you can use
### >, < with your objects
@dataclass(order=True) # without order=True >, < are not defined
class Bike:
  brand: str
  price: int
  name: str

my_super_bike = Bike("Składak", 9098, "Twoje Mrzenie")
print(f"{my_super_bike.brand =}, {my_super_bike.price =}, {my_super_bike.name =}")

# __repr__ is defined
print(my_super_bike)

# __eq__ is defined
second_bike =  Bike("Składak", 9098, "Twoje Mrzenie")
print()
print(second_bike == my_super_bike)

third_bike =  Bike("Składak", 98, "Twoje Mrzenie")
print(second_bike < third_bike)


```


# Type Hint
```python
from dataclasses import dataclass
from typing import Any 

@dataclass
class Paczek:
  type_: Any
  price: float
  name: str 

paczek = Paczek(1, "8.5", "Pączek ze Smoczym Owocem")
print(paczek)
```

other way
```python
from dataclasses import dataclass

@dataclass
class Paczek:
  type_: object
  price: object
  name: object 

paczek = Paczek(1, "8.5", "Pączek ze Smoczym Owocem")
print(paczek)
```

other way
```python
from dataclasses import dataclass

@dataclass
class Paczek:
  type_: ...
  price: ...
  name: ... 
  
paczek = Paczek(1, "8.5", "Pączek ze Smoczym Owocem")
print(paczek)
```


-----
# Customizing Fields














